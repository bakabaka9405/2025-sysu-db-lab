# 数据库设计

## 1. 概念结构设计（E-R图）

### 1.1 核心实体

#### 用户实体（User）
- **属性**：
  - 用户ID（主键）
  - 用户名
  - 密码（加密）
  - 真实姓名
  - 手机号
  - 身份证号
  - 邮箱
  - 角色（用户/管理员/员工）
  - 创建时间
  - 更新时间

#### 包裹实体（Parcel）
- **属性**：
  - 包裹ID（主键）
  - 快递单号（唯一）
  - 取件码（唯一）
  - 收件人姓名
  - 收件人手机号
  - 收件人身份证号
  - 快递公司
  - 包裹大小（小/中/大）
  - 包裹重量
  - 包裹状态（入库/上架/待取/已取/滞留/退回）
  - 货架ID（外键）
  - 入库时间
  - 上架时间
  - 取件时间
  - 预计滞留时间
  - 备注
  - 创建时间
  - 更新时间

#### 货架实体（Shelf）
- **属性**：
  - 货架ID（主键）
  - 货架编号
  - 区域（A区/B区/C区等）
  - 层号
  - 列号
  - 货架类型（小件/中件/大件）
  - 容量
  - 当前占用数
  - 状态（可用/维护/停用）
  - 创建时间
  - 更新时间

#### 寄件实体（Shipment）
- **属性**：
  - 寄件ID（主键）
  - 寄件单号
  - 寄件人ID（外键）
  - 寄件人姓名
  - 寄件人手机号
  - 收件人姓名
  - 收件人手机号
  - 收件地址
  - 快递公司
  - 包裹重量
  - 包裹体积
  - 运费
  - 寄件状态（待寄/已寄/运输中/已送达）
  - 寄件时间
  - 创建时间
  - 更新时间

#### 操作日志实体（OperationLog）
- **属性**：
  - 日志ID（主键）
  - 操作人ID（外键）
  - 操作类型（入库/取件/退回等）
  - 操作对象类型（包裹/货架/用户）
  - 操作对象ID
  - 操作描述
  - IP地址
  - 操作时间

#### 滞留记录实体（OverdueRecord）
- **属性**：
  - 记录ID（主键）
  - 包裹ID（外键）
  - 滞留开始时间
  - 提醒次数
  - 最后提醒时间
  - 滞留费用
  - 处理状态（待处理/已提醒/已退回）
  - 创建时间
  - 更新时间

### 1.2 实体关系

```
E-R关系描述：

1. User ←→ Parcel (1:N)
   - 一个用户可以有多个包裹
   - 关系属性：收件关系

2. Shelf ←→ Parcel (1:N)
   - 一个货架可以存放多个包裹
   - 一个包裹只能存放在一个货架
   - 关系属性：存放关系

3. User ←→ Shipment (1:N)
   - 一个用户可以寄多个件
   - 关系属性：寄件关系

4. Parcel ←→ OverdueRecord (1:1)
   - 一个包裹对应一条滞留记录（如果滞留）
   - 关系属性：滞留关系

5. User ←→ OperationLog (1:N)
   - 一个用户可以产生多条操作日志
   - 关系属性：操作关系
```

### 1.3 E-R图（文字描述）

```
┌──────────────┐
│     User     │
│  (用户实体)   │
└──────┬───────┘
       │ 1
       │ 收件
       │
       │ N
┌──────▼───────┐         N        ┌──────────────┐
│    Parcel    │◄────────────────►│    Shelf     │
│  (包裹实体)   │      存放于       │  (货架实体)   │
└──────┬───────┘         1        └──────────────┘
       │ 1
       │ 产生
       │
       │ 1
┌──────▼───────────┐
│  OverdueRecord   │
│ (滞留记录实体)    │
└──────────────────┘

┌──────────────┐         1        ┌──────────────┐
│     User     │────────────────►│  Shipment    │
│  (用户实体)   │      寄件        │  (寄件实体)   │
└──────┬───────┘         N        └──────────────┘
       │ 1
       │ 产生
       │
       │ N
┌──────▼───────────┐
│  OperationLog    │
│ (操作日志实体)    │
└──────────────────┘
```

## 2. 逻辑结构设计（关系模式）

### 2.1 关系模式定义

#### User（用户表）
```
User (
    id [PK],
    username [UNIQUE],
    password,
    real_name,
    phone [UNIQUE, INDEX],
    id_card [UNIQUE, INDEX],
    email,
    role,
    created_at,
    updated_at,
    deleted_at
)
```
- **主键**：id
- **唯一约束**：username, phone, id_card
- **索引**：phone, id_card（支持快速查询）

#### Parcel（包裹表）
```
Parcel (
    id [PK],
    tracking_number [UNIQUE, INDEX],
    pickup_code [UNIQUE, INDEX],
    recipient_name,
    recipient_phone [INDEX],
    recipient_id_card [INDEX],
    courier_company,
    size,
    weight,
    status [INDEX],
    shelf_id [FK -> Shelf.id],
    received_at [INDEX],
    shelved_at,
    picked_up_at,
    expected_overdue_at [INDEX],
    notes,
    created_at,
    updated_at,
    deleted_at
)
```
- **主键**：id
- **外键**：shelf_id → Shelf(id)
- **唯一约束**：tracking_number, pickup_code
- **索引**：
  - tracking_number（快递单号查询）
  - pickup_code（取件码查询）
  - recipient_phone（手机号查询）
  - recipient_id_card（身份证查询）
  - status（状态过滤）
  - received_at（时间范围查询）
  - expected_overdue_at（滞留件扫描）
- **复合索引**：(status, received_at)（状态+时间组合查询）

#### Shelf（货架表）
```
Shelf (
    id [PK],
    shelf_code [UNIQUE],
    area,
    floor,
    column,
    type,
    capacity,
    current_count,
    status,
    created_at,
    updated_at,
    deleted_at
)
```
- **主键**：id
- **唯一约束**：shelf_code
- **复合索引**：(type, status, current_count)（支持货架分配算法）

#### Shipment（寄件表）
```
Shipment (
    id [PK],
    shipment_number [UNIQUE, INDEX],
    sender_id [FK -> User.id],
    sender_name,
    sender_phone,
    recipient_name,
    recipient_phone,
    recipient_address,
    courier_company,
    weight,
    volume,
    freight,
    status [INDEX],
    shipped_at,
    created_at,
    updated_at,
    deleted_at
)
```
- **主键**：id
- **外键**：sender_id → User(id)
- **唯一约束**：shipment_number
- **索引**：shipment_number, status

#### OverdueRecord（滞留记录表）
```
OverdueRecord (
    id [PK],
    parcel_id [FK -> Parcel.id, UNIQUE],
    overdue_start_at,
    reminder_count,
    last_reminder_at,
    overdue_fee,
    status,
    created_at,
    updated_at,
    deleted_at
)
```
- **主键**：id
- **外键**：parcel_id → Parcel(id)
- **唯一约束**：parcel_id（一个包裹只有一条滞留记录）
- **索引**：status, overdue_start_at

#### OperationLog（操作日志表）
```
OperationLog (
    id [PK],
    operator_id [FK -> User.id],
    operation_type [INDEX],
    object_type,
    object_id,
    description,
    ip_address,
    operated_at [INDEX],
    created_at
)
```
- **主键**：id
- **外键**：operator_id → User(id)
- **索引**：operation_type, operated_at
- **复合索引**：(operator_id, operated_at)（查询某用户的操作历史）

### 2.2 函数依赖分析

#### User表
- id → {username, password, real_name, phone, id_card, email, role, ...}
- username → id
- phone → id
- id_card → id
- 满足BCNF范式（所有决定因素都是候选键）

#### Parcel表
- id → {tracking_number, pickup_code, recipient_name, status, shelf_id, ...}
- tracking_number → id
- pickup_code → id
- 满足BCNF范式

#### Shelf表
- id → {shelf_code, area, floor, column, type, capacity, ...}
- shelf_code → id
- 满足BCNF范式

### 2.3 规范化检查

所有表均满足以下范式要求：
- **第一范式（1NF）**：所有属性都是原子值，不可再分
- **第二范式（2NF）**：消除了非主属性对主键的部分依赖
- **第三范式（3NF）**：消除了非主属性对主键的传递依赖
- **BCNF范式**：所有决定因素都是候选键

## 3. 物理结构设计（PostgreSQL）

### 3.1 表结构SQL定义

#### 用户表
```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    real_name VARCHAR(100),
    phone VARCHAR(20) NOT NULL UNIQUE,
    id_card VARCHAR(18) UNIQUE,
    email VARCHAR(100),
    role VARCHAR(20) NOT NULL DEFAULT 'user',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

-- 索引
CREATE INDEX idx_users_phone ON users(phone) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_id_card ON users(id_card) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(role) WHERE deleted_at IS NULL;

-- 注释
COMMENT ON TABLE users IS '用户表';
COMMENT ON COLUMN users.role IS '角色：user-普通用户, admin-管理员, staff-员工';
```

#### 包裹表
```sql
CREATE TABLE parcels (
    id BIGSERIAL PRIMARY KEY,
    tracking_number VARCHAR(50) NOT NULL UNIQUE,
    pickup_code VARCHAR(20) NOT NULL UNIQUE,
    recipient_name VARCHAR(100) NOT NULL,
    recipient_phone VARCHAR(20) NOT NULL,
    recipient_id_card VARCHAR(18),
    courier_company VARCHAR(50) NOT NULL,
    size VARCHAR(20) NOT NULL,
    weight DECIMAL(10, 2),
    status VARCHAR(20) NOT NULL DEFAULT 'received',
    shelf_id BIGINT REFERENCES shelves(id) ON DELETE SET NULL,
    received_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    shelved_at TIMESTAMP,
    picked_up_at TIMESTAMP,
    expected_overdue_at TIMESTAMP,
    notes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

-- 索引
CREATE INDEX idx_parcels_tracking ON parcels(tracking_number) WHERE deleted_at IS NULL;
CREATE INDEX idx_parcels_pickup_code ON parcels(pickup_code) WHERE deleted_at IS NULL;
CREATE INDEX idx_parcels_recipient_phone ON parcels(recipient_phone) WHERE deleted_at IS NULL;
CREATE INDEX idx_parcels_recipient_id_card ON parcels(recipient_id_card) WHERE deleted_at IS NULL;
CREATE INDEX idx_parcels_status ON parcels(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_parcels_received_at ON parcels(received_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_parcels_overdue ON parcels(expected_overdue_at) WHERE status IN ('ready_for_pickup', 'shelved') AND deleted_at IS NULL;
CREATE INDEX idx_parcels_status_received ON parcels(status, received_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_parcels_shelf_status ON parcels(shelf_id, status) WHERE deleted_at IS NULL;

-- 注释
COMMENT ON TABLE parcels IS '包裹表';
COMMENT ON COLUMN parcels.status IS '状态：received-入库, shelved-上架, ready_for_pickup-待取, picked_up-已取, overdue-滞留, returned-退回';
COMMENT ON COLUMN parcels.size IS '大小：small-小件, medium-中件, large-大件';
```

#### 货架表
```sql
CREATE TABLE shelves (
    id BIGSERIAL PRIMARY KEY,
    shelf_code VARCHAR(50) NOT NULL UNIQUE,
    area VARCHAR(10) NOT NULL,
    floor INT NOT NULL,
    column INT NOT NULL,
    type VARCHAR(20) NOT NULL,
    capacity INT NOT NULL DEFAULT 10,
    current_count INT NOT NULL DEFAULT 0,
    status VARCHAR(20) NOT NULL DEFAULT 'available',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP,
    CONSTRAINT chk_current_count CHECK (current_count >= 0 AND current_count <= capacity)
);

-- 索引
CREATE INDEX idx_shelves_type_status ON shelves(type, status, current_count) WHERE deleted_at IS NULL;
CREATE INDEX idx_shelves_area ON shelves(area, floor, column) WHERE deleted_at IS NULL;
CREATE UNIQUE INDEX idx_shelves_position ON shelves(area, floor, column) WHERE deleted_at IS NULL;

-- 注释
COMMENT ON TABLE shelves IS '货架表';
COMMENT ON COLUMN shelves.type IS '类型：small-小件货架, medium-中件货架, large-大件货架';
COMMENT ON COLUMN shelves.status IS '状态：available-可用, maintenance-维护中, disabled-停用';
```

#### 寄件表
```sql
CREATE TABLE shipments (
    id BIGSERIAL PRIMARY KEY,
    shipment_number VARCHAR(50) NOT NULL UNIQUE,
    sender_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
    sender_name VARCHAR(100) NOT NULL,
    sender_phone VARCHAR(20) NOT NULL,
    recipient_name VARCHAR(100) NOT NULL,
    recipient_phone VARCHAR(20) NOT NULL,
    recipient_address TEXT NOT NULL,
    courier_company VARCHAR(50) NOT NULL,
    weight DECIMAL(10, 2) NOT NULL,
    volume DECIMAL(10, 2),
    freight DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    shipped_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

-- 索引
CREATE INDEX idx_shipments_number ON shipments(shipment_number) WHERE deleted_at IS NULL;
CREATE INDEX idx_shipments_sender ON shipments(sender_id, created_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_shipments_status ON shipments(status) WHERE deleted_at IS NULL;

-- 注释
COMMENT ON TABLE shipments IS '寄件表';
COMMENT ON COLUMN shipments.status IS '状态：pending-待寄, shipped-已寄, in_transit-运输中, delivered-已送达';
```

#### 滞留记录表
```sql
CREATE TABLE overdue_records (
    id BIGSERIAL PRIMARY KEY,
    parcel_id BIGINT NOT NULL UNIQUE REFERENCES parcels(id) ON DELETE CASCADE,
    overdue_start_at TIMESTAMP NOT NULL,
    reminder_count INT NOT NULL DEFAULT 0,
    last_reminder_at TIMESTAMP,
    overdue_fee DECIMAL(10, 2) NOT NULL DEFAULT 0,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

-- 索引
CREATE INDEX idx_overdue_status ON overdue_records(status, overdue_start_at) WHERE deleted_at IS NULL;
CREATE INDEX idx_overdue_parcel ON overdue_records(parcel_id) WHERE deleted_at IS NULL;

-- 注释
COMMENT ON TABLE overdue_records IS '滞留记录表';
COMMENT ON COLUMN overdue_records.status IS '状态：pending-待处理, reminded-已提醒, returned-已退回';
```

#### 操作日志表
```sql
CREATE TABLE operation_logs (
    id BIGSERIAL PRIMARY KEY,
    operator_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
    operation_type VARCHAR(50) NOT NULL,
    object_type VARCHAR(50) NOT NULL,
    object_id BIGINT NOT NULL,
    description TEXT,
    ip_address VARCHAR(50),
    operated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_logs_operator ON operation_logs(operator_id, operated_at DESC);
CREATE INDEX idx_logs_type ON operation_logs(operation_type, operated_at DESC);
CREATE INDEX idx_logs_object ON operation_logs(object_type, object_id, operated_at DESC);
CREATE INDEX idx_logs_operated_at ON operation_logs(operated_at DESC);

-- 分区（按月分区，优化历史数据查询）
-- 示例：为2025年1月创建分区
-- CREATE TABLE operation_logs_2025_01 PARTITION OF operation_logs
-- FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- 注释
COMMENT ON TABLE operation_logs IS '操作日志表';
COMMENT ON COLUMN operation_logs.operation_type IS '操作类型：parcel_received, parcel_picked_up, parcel_returned等';
```

### 3.2 索引策略

#### 3.2.1 单列索引
- **主键索引**：所有表的id字段（自动创建）
- **唯一索引**：username, phone, tracking_number, pickup_code等
- **普通索引**：高频查询字段（status, received_at等）

#### 3.2.2 复合索引
- `(status, received_at)`：支持按状态和时间组合查询
- `(type, status, current_count)`：支持货架分配算法
- `(operator_id, operated_at)`：支持用户操作历史查询

#### 3.2.3 部分索引
使用`WHERE deleted_at IS NULL`创建部分索引，只索引未删除的数据，减少索引大小，提升性能。

#### 3.2.4 索引维护
- 定期使用`REINDEX`重建索引
- 使用`VACUUM`清理死元组
- 监控索引使用情况（pg_stat_user_indexes）

### 3.3 分区设计

#### 操作日志表分区（按月）
```sql
CREATE TABLE operation_logs (
    ...
) PARTITION BY RANGE (operated_at);

-- 创建分区表
CREATE TABLE operation_logs_2025_01 PARTITION OF operation_logs
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE operation_logs_2025_02 PARTITION OF operation_logs
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

优势：
- 提高历史数据查询性能
- 便于归档和清理旧数据
- 减少索引大小

#### 包裹表分区（可选，数据量大时）
如果包裹数据量超过千万级别，可以考虑按状态或时间分区。

### 3.4 约束设计

#### CHECK约束
```sql
-- 货架占用数不能超过容量
ALTER TABLE shelves ADD CONSTRAINT chk_current_count
CHECK (current_count >= 0 AND current_count <= capacity);

-- 包裹重量必须为正数
ALTER TABLE parcels ADD CONSTRAINT chk_weight
CHECK (weight > 0);

-- 运费必须为正数
ALTER TABLE shipments ADD CONSTRAINT chk_freight
CHECK (freight >= 0);
```

#### 外键约束
- `parcels.shelf_id` → `shelves.id` (ON DELETE SET NULL)
- `shipments.sender_id` → `users.id` (ON DELETE SET NULL)
- `overdue_records.parcel_id` → `parcels.id` (ON DELETE CASCADE)
- `operation_logs.operator_id` → `users.id` (ON DELETE SET NULL)

### 3.5 触发器设计

#### 自动更新updated_at触发器
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 为各表创建触发器
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_parcels_updated_at BEFORE UPDATE ON parcels
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ...其他表类似
```

#### 货架占用数自动更新触发器
```sql
CREATE OR REPLACE FUNCTION update_shelf_count()
RETURNS TRIGGER AS $$
BEGIN
    -- 包裹上架时，增加货架占用数
    IF (TG_OP = 'UPDATE' AND NEW.shelf_id IS NOT NULL AND NEW.status = 'shelved') THEN
        UPDATE shelves SET current_count = current_count + 1 WHERE id = NEW.shelf_id;
    END IF;

    -- 包裹取走时，减少货架占用数
    IF (TG_OP = 'UPDATE' AND OLD.shelf_id IS NOT NULL AND NEW.status = 'picked_up') THEN
        UPDATE shelves SET current_count = current_count - 1 WHERE id = OLD.shelf_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_shelf_count AFTER UPDATE ON parcels
    FOR EACH ROW EXECUTE FUNCTION update_shelf_count();
```

### 3.6 性能优化配置

#### 连接池配置（应用层GORM）
```go
db.DB().SetMaxIdleConns(10)     // 最大空闲连接数
db.DB().SetMaxOpenConns(100)    // 最大打开连接数
db.DB().SetConnMaxLifetime(time.Hour) // 连接最大生命周期
```

#### PostgreSQL配置建议
```conf
# 共享内存
shared_buffers = 256MB

# 工作内存
work_mem = 4MB

# 维护工作内存
maintenance_work_mem = 64MB

# 有效缓存大小
effective_cache_size = 1GB

# 随机页面成本
random_page_cost = 1.1  # SSD环境可以降低

# 并行查询
max_parallel_workers_per_gather = 2

# WAL配置
wal_buffers = 16MB
checkpoint_completion_target = 0.9
```

### 3.7 数据备份策略

#### 逻辑备份（pg_dump）
```bash
# 每日全量备份
pg_dump -h localhost -U postgres -d logistics_db -F c -f backup_$(date +%Y%m%d).dump

# 增量备份（使用WAL归档）
```

#### 物理备份
- 使用pg_basebackup进行物理备份
- 配置WAL归档实现PITR（时间点恢复）

### 3.8 数据字典

#### 包裹状态枚举
| 状态值 | 说明 | 流转方向 |
|--------|------|----------|
| received | 已入库 | → shelved |
| shelved | 已上架 | → ready_for_pickup |
| ready_for_pickup | 待取件 | → picked_up / overdue |
| picked_up | 已取件 | 终态 |
| overdue | 滞留 | → returned |
| returned | 已退回 | 终态 |

#### 货架类型枚举
| 类型值 | 说明 | 适用包裹大小 |
|--------|------|--------------|
| small | 小件货架 | 小件包裹 |
| medium | 中件货架 | 中件包裹 |
| large | 大件货架 | 大件包裹 |

#### 用户角色枚举
| 角色值 | 说明 | 权限 |
|--------|------|------|
| user | 普通用户 | 查询自己的包裹、寄件 |
| staff | 驿站员工 | 包裹入库、取件确认、货架管理 |
| admin | 系统管理员 | 所有权限 |

## 4. 数据完整性保证

### 4.1 实体完整性
- 所有表都有主键约束
- 主键使用BIGSERIAL自增

### 4.2 参照完整性
- 外键约束保证关联数据一致性
- 合理设置ON DELETE策略（CASCADE/SET NULL）

### 4.3 用户定义完整性
- CHECK约束保证数据范围合法性
- UNIQUE约束保证数据唯一性
- NOT NULL约束保证必填字段

### 4.4 事务完整性
- 使用数据库事务保证操作原子性
- 在Service层使用Transaction Manager统一管理事务

## 5. 查询优化示例

### 5.1 高频查询SQL

#### 通过取件码查询包裹
```sql
SELECT p.*, s.shelf_code, s.area, s.floor, s.column
FROM parcels p
LEFT JOIN shelves s ON p.shelf_id = s.id
WHERE p.pickup_code = $1 AND p.deleted_at IS NULL;
```
优化：pickup_code上有唯一索引，查询效率O(log n)

#### 查询待取件包裹（分页）
```sql
SELECT *
FROM parcels
WHERE status = 'ready_for_pickup' AND deleted_at IS NULL
ORDER BY received_at DESC
LIMIT 20 OFFSET 0;
```
优化：使用(status, received_at)复合索引，支持索引覆盖扫描

#### 查询滞留包裹
```sql
SELECT p.*, u.phone
FROM parcels p
JOIN users u ON p.recipient_phone = u.phone
WHERE p.status IN ('ready_for_pickup', 'shelved')
  AND p.expected_overdue_at < CURRENT_TIMESTAMP
  AND p.deleted_at IS NULL;
```
优化：expected_overdue_at上有部分索引，定时任务高效扫描

#### 统计各状态包裹数量
```sql
SELECT status, COUNT(*) as count
FROM parcels
WHERE deleted_at IS NULL
GROUP BY status;
```
优化：status字段有索引，聚合效率高

### 5.2 慢查询优化策略
1. 使用EXPLAIN ANALYZE分析查询计划
2. 避免SELECT *，只查询需要的字段
3. 合理使用JOIN，避免过多表关联
4. 使用索引覆盖扫描（Index Only Scan）
5. 分页查询使用游标或者KEYSET分页
6. 避免在WHERE子句中对索引列使用函数

## 6. 数据迁移脚本

### 6.1 初始化脚本
```sql
-- 创建数据库
CREATE DATABASE logistics_db WITH ENCODING 'UTF8';

-- 创建扩展
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";  -- UUID生成
CREATE EXTENSION IF NOT EXISTS "pg_trgm";     -- 模糊查询优化

-- 创建schema
CREATE SCHEMA IF NOT EXISTS public;
```

### 6.2 测试数据生成
```sql
-- 插入测试用户
INSERT INTO users (username, password, real_name, phone, role)
VALUES
  ('admin', '$2a$10$...', '管理员', '13800138000', 'admin'),
  ('staff001', '$2a$10$...', '员工001', '13800138001', 'staff');

-- 插入测试货架
INSERT INTO shelves (shelf_code, area, floor, column, type, capacity)
VALUES
  ('A-01-01', 'A', 1, 1, 'small', 20),
  ('A-01-02', 'A', 1, 2, 'medium', 15),
  ('A-01-03', 'A', 1, 3, 'large', 10);
```

## 7. 总结

本数据库设计遵循以下原则：
1. **规范化**：满足BCNF范式，消除冗余
2. **性能优化**：合理设计索引、分区，支持高并发查询
3. **数据完整性**：完善的约束和触发器保证数据一致性
4. **可扩展性**：预留扩展字段，支持业务迭代
5. **可维护性**：清晰的表结构、完善的注释和文档
