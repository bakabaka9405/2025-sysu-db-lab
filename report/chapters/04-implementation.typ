= 系统详细设计与实现

本章介绍系统架构的实现方式、核心功能模块的设计思路以及关键代码示例，重点展示如何在应用层调用数据库高级特性。系统架构设计参考了企业应用架构模式 @fowler2002 和微服务设计理念 @newman2021。

== 系统架构实现

系统采用经典的三层架构模式:Handler层(HTTP处理)、Service层(业务逻辑)、Repository层(数据访问)，配合依赖注入实现松耦合设计。

=== 分层架构

/ Handler层: 负责接收HTTP请求，参数验证和绑定，调用Service层处理业务，格式化响应。每个Handler对应一组相关的API端点。

/ Service层: 实现核心业务逻辑，协调多个Repository进行数据操作，管理事务边界。Service层是系统的业务中枢。

/ Repository层: 封装数据库操作，提供统一的数据访问接口。通过GORM调用SQL或存储过程，隐藏数据持久化细节。

/ Model层: 定义领域实体和数据传输对象(DTO)，与数据库表结构映射。

=== 依赖注入设计

使用Google Wire进行编译时依赖注入，通过代码生成避免运行时反射开销。Wire将系统组件组织为多个Provider集合：`repositorySet`提供数据库连接和所有Repository实例，`serviceSet`提供所有Service实例并依赖于Repository，`handlerSet`提供所有Handler实例并依赖于Service，`serverSet`提供HTTP服务器配置。Wire在编译时生成依赖注入代码，确保依赖关系正确且类型安全。

== 核心功能模块实现

=== 包裹入库与上架模块

包裹入库是系统的核心功能之一，涉及货架分配、取件码生成等复杂逻辑。

==== 业务流程

+ 接收包裹基本信息(快递单号、收件人、包裹大小等);
+ 调用`receive_parcel()`存储过程:
  - 调用`generate_pickup_code()`生成唯一取件码；
  - 插入包裹记录，状态为"已入库"，暂不分配货架；
+ 返回包裹ID和取件码，包裹可暂存于临时区域。
+ 工作人员选择已入库的包裹执行上架操作；
+ 调用`shelve_parcel()`存储过程:
  - 调用`allocate_shelf()`分配最优货架；
  - 更新包裹状态为"待取件"；
  - 触发器自动维护货架计数和时间戳；
+ 发送取件通知给用户。


==== 关键代码(Repository层调用存储过程)

#raw(read("../assets/go/receive-parcel-repository.go"), lang: "go", block: true)

*设计说明*：通过调用存储过程，将复杂的货架分配算法和取件码生成逻辑下沉到数据库层，应用层代码简洁清晰，且保证了业务逻辑的一致性。

=== 包裹取件模块

取件模块需要处理并发场景，防止重复取件。

==== 并发控制

使用数据库行级锁(`FOR UPDATE`)和事务控制，确保并发安全:

#raw(read("../assets/go/pickup-parcel-repository.go"), lang: "go", block: true)

*设计说明*:`FOR UPDATE`锁定查询到的包裹记录，防止并发冲突；事务确保取件操作的原子性。

=== 货架分配算法

货架分配算法封装在数据库函数`allocate_shelf()`中，综合考虑多个因子。算法采用多因子评分机制，其中空间因子权重为0.5，优先选择剩余空间大的货架；位置因子权重为0.3，优先选择低楼层和前列位置，便于取件；负载因子权重为0.2，用于平衡各货架负载，避免某个货架过载。算法的SQL实现已在第3章展示，应用层只需调用该函数即可获得最优货架ID。

=== 运费计算模块

运费计算规则复杂，涉及首重续重、体积重量、附加费用等。

==== 计算规则

+ 获取快递公司的价格配置(首重、首重价格、续重价格)；
+ 计算体积重量；
+ 取实际重量和体积重量的较大值作为计费重量；
+ 计算基础运费:
  - 若$"计费重量"≤"首重"$，$"运费"="首重价格"$；
  - 否则，$"运费"="首重价格"+ceil("计费重量"-"首重")×"续重价格"$；
+ 可选：添加保价费、签收回单费等附加费用。

==== 调用数据库函数

#raw(read("../assets/go/calculate-freight-repository.go"), lang: "go", block: true)

运费计算逻辑统一封装在数据库中，避免应用层重复实现，且便于后续调整价格策略。

=== 滞留件处理

滞留件处理通过定时任务(cron)和数据库视图、函数联动实现自动化。

==== 自动识别机制

+ 定时任务(每天凌晨)扫描视图`v_pending_overdue_parcels`;
+ 视图自动计算滞留天数和费用，筛选出超期未取的包裹；
+ 更新包裹状态为“滞留”，创建滞留记录；
+ 调用第三方服务发送提醒通知。

==== 定时任务代码

#raw(read("../assets/go/overdue-job.go"), lang: "go", block: true)

通过视图简化查询逻辑，定时任务只需关注业务流程，无需关心复杂的SQL计算。

== API接口设计

系统采用RESTful API设计规范，提供统一的接口风格。

=== RESTful规范

系统使用标准HTTP方法表达操作语义：GET用于查询、POST用于创建、PUT用于更新、DELETE用于删除。资源采用复数名词命名，如`/api/v1/parcels`和`/api/v1/shelves`。HTTP状态码用于表示请求结果，其中200表示成功、400表示参数错误、401表示未认证、403表示无权限、404表示资源不存在等。

=== 统一响应格式

#raw(read("../assets/api-examples/response-success.json"), lang: "json", block: true)

错误响应示例:
#raw(read("../assets/api-examples/response-error.json"), lang: "json", block: true)

=== 核心接口示例

*包裹入库接口*
#raw(read("../assets/api-examples/receive-parcel-request.txt"), block: true)

*包裹取件接口*
#raw(read("../assets/api-examples/pickup-parcel-request.txt"), block: true)

== 性能优化措施

=== 数据库层优化

数据库层优化涵盖多个方面。索引优化针对高频查询字段建立索引，包括取件码、快递单号和手机号等。部分索引只索引未删除数据，有效减少索引大小。视图缓存使用物化视图缓存复杂聚合结果并定期刷新。连接池配置合理的参数以避免连接耗尽。慢查询监控记录执行时间超过100ms的查询以进行针对性优化。

=== 应用层优化

应用层采用多种优化策略。分页查询使用游标分页，适合大数据量场景且性能稳定。批量操作通过批量插入和更新减少数据库交互次数。缓存策略使用Redis缓存热点数据，如货架利用率等。异步处理将通知发送、日志记录等非关键操作改为异步执行。限流降级在高峰期对非核心接口进行限流，保证核心功能可用。

=== 前端优化

前端优化同样采用多种策略。虚拟滚动使大数据列表只渲染可见区域。防抖节流对搜索框输入和按钮点击等操作加以控制。懒加载使图片和组件按需加载，减少首屏加载时间。资源压缩通过代码混淆压缩和Gzip传输压缩减小传输体积。

== 安全性设计

=== 身份认证

采用JWT Token机制，流程如下:

+ 用户登录，服务器验证用户名密码；
+ 验证通过后生成JWT Token(包含用户ID、角色、过期时间);
+ 客户端将Token存储在localStorage;
+ 后续请求在HTTP头中携带Token:`Authorization: Bearer <token>`;
+ 服务器验证Token有效性，提取用户信息。

=== 权限控制

系统采用RBAC模型，定义了三种用户角色。普通用户(user)可查询自己的包裹和创建寄件单；驿站员工(staff)可进行包裹入库、取件操作以及查询所有包裹；管理员(admin)可进行用户管理、系统配置和数据导出。

权限控制的实现分为三个层次。首先是JWT Token层，用户登录成功后，系统生成的JWT Token中不仅包含用户ID，还包含用户角色信息，使得后续请求无需查询数据库即可验证用户权限。其次是中间件层，系统实现了`RequireRole`中间件，该中间件从JWT Claims中提取用户角色，检查是否在允许的角色列表中，未授权请求返回HTTP 403 Forbidden错误。最后是路由层，敏感操作接口（如包裹入库、货架管理、滞留件处理）在路由配置时链式调用认证中间件和角色检查中间件，确保只有具备相应权限的用户才能访问。

前端同样实现了权限控制机制。导航菜单根据用户角色动态显示，普通用户可见"我的包裹"和"我的寄件"菜单，而员工和管理员则可见"包裹管理"、"货架管理"和"滞留件管理"菜单。路由守卫进一步确保用户无法通过直接输入URL访问无权限的页面，形成前后端双重权限校验的安全机制。

=== 数据安全

系统采用多层次的数据安全保护措施。密码使用bcrypt算法加密存储，有效防止明文泄露。敏感信息如身份证号通过视图脱敏展示。通过使用GORM参数化查询和存储过程实现SQL注入防护。通过前端对用户输入进行转义实现XSS防护。生产环境启用HTTPS传输，防止中间人攻击。

本章从系统架构到核心模块实现，从API设计到性能优化和安全防护，全面展示了系统的技术实现方案。通过合理的架构设计和对数据库高级特性的充分利用，系统在保证功能完整性的同时，兼顾了性能、安全和可维护性。
