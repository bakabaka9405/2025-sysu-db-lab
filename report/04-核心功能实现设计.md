# 核心功能实现设计

## 1. 货架分配算法

### 1.1 算法目标
- 根据包裹大小自动分配合适的货架
- 优化货架空间利用率
- 平衡各区域货架负载
- 提高取件效率（优先分配易到达位置）

### 1.2 算法策略

#### 1.2.1 基于包裹大小的类型匹配
```
包裹大小  →  货架类型
small    →  small货架（优先）> medium货架（备选）> large货架（兜底）
medium   →  medium货架（优先）> large货架（备选）
large    →  large货架（唯一选择）
```

#### 1.2.2 货架优先级计算公式
```
优先级分数 = W1 × 空间因子 + W2 × 位置因子 + W3 × 负载因子

其中：
- 空间因子 = (capacity - current_count) / capacity
  （剩余空间比例，值越大越好）

- 位置因子 = 1 / (floor + column)
  （楼层和列号越小越好，便于取件）

- 负载因子 = 1 - (current_count / capacity)
  （当前负载越低越好，平衡负载）

- 权重：W1 = 0.5, W2 = 0.3, W3 = 0.2
```

### 1.3 算法流程

```
输入：parcel (size: small/medium/large)
输出：shelf_id

流程：
1. 根据包裹大小确定候选货架类型列表
   - small包裹: [small, medium, large]
   - medium包裹: [medium, large]
   - large包裹: [large]

2. 按类型优先级查询可用货架
   FOR EACH type IN candidate_types:
       shelves = SELECT * FROM shelves
                 WHERE type = type
                   AND status = 'available'
                   AND current_count < capacity
                   AND deleted_at IS NULL
                 ORDER BY (优先级分数) DESC
                 LIMIT 10

       IF shelves NOT EMPTY:
           BREAK

3. 如果没有可用货架
   - 返回错误：货架已满，请联系管理员

4. 计算每个候选货架的优先级分数
   FOR EACH shelf IN shelves:
       shelf.priority = calculate_priority(shelf)

5. 选择优先级最高的货架
   selected_shelf = MAX(shelves, key=priority)

6. 返回选中的货架ID
   RETURN selected_shelf.id
```

### 1.4 伪代码实现

```go
type ShelfAllocator struct {
    repo repository.ShelfRepository
}

func (sa *ShelfAllocator) AllocateShelf(ctx context.Context, parcelSize string) (*model.Shelf, error) {
    // 1. 确定候选货架类型
    candidateTypes := getCandidateTypes(parcelSize)

    // 2. 按优先级查询可用货架
    var availableShelves []*model.Shelf
    for _, shelfType := range candidateTypes {
        shelves, err := sa.repo.FindAvailableShelves(ctx, shelfType, 10)
        if err != nil {
            return nil, err
        }
        if len(shelves) > 0 {
            availableShelves = shelves
            break
        }
    }

    // 3. 检查是否有可用货架
    if len(availableShelves) == 0 {
        return nil, errors.New("no available shelf")
    }

    // 4. 计算优先级并选择最佳货架
    bestShelf := selectBestShelf(availableShelves)

    return bestShelf, nil
}

func getCandidateTypes(parcelSize string) []string {
    switch parcelSize {
    case "small":
        return []string{"small", "medium", "large"}
    case "medium":
        return []string{"medium", "large"}
    case "large":
        return []string{"large"}
    default:
        return []string{"medium"}
    }
}

func selectBestShelf(shelves []*model.Shelf) *model.Shelf {
    var bestShelf *model.Shelf
    maxPriority := 0.0

    for _, shelf := range shelves {
        priority := calculatePriority(shelf)
        if priority > maxPriority {
            maxPriority = priority
            bestShelf = shelf
        }
    }

    return bestShelf
}

func calculatePriority(shelf *model.Shelf) float64 {
    // 权重
    w1, w2, w3 := 0.5, 0.3, 0.2

    // 空间因子
    spaceFactor := float64(shelf.Capacity-shelf.CurrentCount) / float64(shelf.Capacity)

    // 位置因子（楼层和列号越小越好）
    locationFactor := 1.0 / float64(shelf.Floor+shelf.Column)

    // 负载因子
    loadFactor := 1.0 - float64(shelf.CurrentCount)/float64(shelf.Capacity)

    // 综合优先级
    priority := w1*spaceFactor + w2*locationFactor + w3*loadFactor

    return priority
}
```

### 1.5 SQL优化

```sql
-- 高效的货架查询（使用复合索引）
SELECT *
FROM shelves
WHERE type = $1
  AND status = 'available'
  AND current_count < capacity
  AND deleted_at IS NULL
ORDER BY
  (capacity - current_count)::float / capacity DESC,  -- 空间因子
  1.0 / (floor + column) DESC,                         -- 位置因子
  1.0 - (current_count::float / capacity) DESC        -- 负载因子
LIMIT 10;
```

## 2. 取件码生成算法

### 2.1 设计目标
- 唯一性：保证取件码全局唯一
- 简洁性：便于用户输入和记忆（6位字符）
- 安全性：不易被猜测或枚举
- 可读性：避免易混淆字符（0/O, 1/I/l等）

### 2.2 取件码规则

#### 格式
```
取件码格式：XNNNNN
- 第1位：区域字母（A-Z）
- 第2-6位：5位数字和大写字母组合

示例：A12B45, C98K23, F23M67
```

#### 字符集
```
区域字母：A-Z（26个字母）
后续字符：数字0-9 + 大写字母去除易混淆字母（0, O, 1, I, L）
可用字符：0-9, A-Z (共36个) - {O, I, L} = 33个字符
```

### 2.3 生成算法

#### 方案1：随机生成 + 唯一性校验（推荐）

```go
const (
    PickupCodeLength = 6
    AreaLetters      = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    ValidChars       = "0123456789ABCDEFGHJKMNPQRSTUVWXYZ" // 去除O, I, L
)

type PickupCodeGenerator struct {
    repo repository.ParcelRepository
}

func (g *PickupCodeGenerator) Generate(ctx context.Context, shelfArea string) (string, error) {
    // 最多尝试10次
    maxRetries := 10

    for i := 0; i < maxRetries; i++ {
        // 生成候选取件码
        code := generateRandomCode(shelfArea)

        // 检查唯一性
        exists, err := g.repo.ExistsByPickupCode(ctx, code)
        if err != nil {
            return "", err
        }

        if !exists {
            return code, nil
        }
    }

    return "", errors.New("failed to generate unique pickup code")
}

func generateRandomCode(area string) string {
    // 第1位：区域字母（从货架区域获取，如果为空则随机）
    var firstChar string
    if area != "" && len(area) > 0 {
        firstChar = string(area[0])
    } else {
        firstChar = string(AreaLetters[rand.Intn(len(AreaLetters))])
    }

    // 第2-6位：随机字符
    remaining := make([]byte, 5)
    for i := 0; i < 5; i++ {
        remaining[i] = ValidChars[rand.Intn(len(ValidChars))]
    }

    return firstChar + string(remaining)
}
```

#### 方案2：基于序列号 + 编码（高并发场景）

```go
// 使用数据库序列号 + Base33编码
func GenerateFromSequence(seqNumber int64, area string) string {
    // 将序列号转换为Base33编码（使用ValidChars字符集）
    encoded := encodeBase33(seqNumber)

    // 补齐到5位
    for len(encoded) < 5 {
        encoded = "0" + encoded
    }

    // 截取最后5位
    if len(encoded) > 5 {
        encoded = encoded[len(encoded)-5:]
    }

    return area + encoded
}

func encodeBase33(num int64) string {
    if num == 0 {
        return "0"
    }

    base := int64(len(ValidChars))
    result := ""

    for num > 0 {
        remainder := num % base
        result = string(ValidChars[remainder]) + result
        num = num / base
    }

    return result
}
```

### 2.4 唯一性保证

#### 数据库层面
```sql
-- 唯一索引
CREATE UNIQUE INDEX idx_parcels_pickup_code
ON parcels(pickup_code)
WHERE deleted_at IS NULL;

-- 插入时冲突处理
INSERT INTO parcels (tracking_number, pickup_code, ...)
VALUES ($1, $2, ...)
ON CONFLICT (pickup_code) DO NOTHING
RETURNING id;
```

#### 应用层面
- 生成后立即校验唯一性
- 失败重试机制（最多10次）
- 使用分布式锁防止并发冲突（高并发场景）

### 2.5 取件码碰撞概率分析

```
字符空间：
- 第1位：26种（A-Z）
- 第2-6位：33^5 = 39,135,393 种

总空间：26 × 33^5 ≈ 10.2亿

如果系统中有100万个有效取件码：
碰撞概率 ≈ 1,000,000 / 1,020,000,000 ≈ 0.098%

结论：6位取件码对于校园场景完全够用
```

## 3. 运费计算算法

### 3.1 计费规则

#### 3.1.1 基础运费
不同快递公司的首重和续重价格不同：

| 快递公司 | 首重(kg) | 首重价格(元) | 续重价格(元/kg) |
|----------|----------|--------------|----------------|
| 顺丰速运 | 1 | 15 | 5 |
| 中通快递 | 1 | 10 | 3 |
| 圆通快递 | 1 | 10 | 3 |
| 韵达快递 | 1 | 10 | 3 |
| 申通快递 | 1 | 10 | 3 |
| 邮政EMS | 1 | 12 | 4 |

#### 3.1.2 体积重量
当包裹体积较大时，使用体积重量计费：
```
体积重量(kg) = 长(cm) × 宽(cm) × 高(cm) / 6000

实际计费重量 = MAX(实际重量, 体积重量)
```

#### 3.1.3 特殊费用（可选）
- 保价费用：声明价值 × 0.5%（最低2元）
- 签收回单：5元/单
- 代收货款：货款金额 × 1%（最低5元）

### 3.2 计算算法

```go
type FreightCalculator struct {
    priceRepo repository.CourierPriceRepository
}

type FreightParams struct {
    CourierCompany string  // 快递公司
    Weight         float64 // 实际重量(kg)
    Volume         float64 // 体积(m³)
    DeclaredValue  float64 // 声明价值(元)，可选
    RequireReceipt bool    // 是否需要签收回单
}

type FreightResult struct {
    TotalFreight       float64 // 总运费
    BaseFreight        float64 // 基础运费
    InsuranceFee       float64 // 保价费
    ReceiptFee         float64 // 签收回单费
    ChargeableWeight   float64 // 计费重量
    CalculationDetails string  // 计算明细
}

func (fc *FreightCalculator) Calculate(ctx context.Context, params FreightParams) (*FreightResult, error) {
    // 1. 获取快递公司价格配置
    priceConfig, err := fc.priceRepo.GetByCourierCompany(ctx, params.CourierCompany)
    if err != nil {
        return nil, err
    }

    // 2. 计算体积重量
    volumeWeight := calculateVolumeWeight(params.Volume)

    // 3. 确定计费重量
    chargeableWeight := max(params.Weight, volumeWeight)

    // 4. 计算基础运费
    baseFreight := calculateBaseFreight(chargeableWeight, priceConfig)

    // 5. 计算保价费
    insuranceFee := 0.0
    if params.DeclaredValue > 0 {
        insuranceFee = max(params.DeclaredValue*0.005, 2.0)
    }

    // 6. 计算签收回单费
    receiptFee := 0.0
    if params.RequireReceipt {
        receiptFee = 5.0
    }

    // 7. 计算总运费
    totalFreight := baseFreight + insuranceFee + receiptFee

    // 8. 生成计算明细
    details := fmt.Sprintf(
        "实际重量: %.2fkg, 体积重量: %.2fkg, 计费重量: %.2fkg\n"+
            "基础运费: %.2f元, 保价费: %.2f元, 签收回单: %.2f元",
        params.Weight, volumeWeight, chargeableWeight,
        baseFreight, insuranceFee, receiptFee,
    )

    return &FreightResult{
        TotalFreight:       totalFreight,
        BaseFreight:        baseFreight,
        InsuranceFee:       insuranceFee,
        ReceiptFee:         receiptFee,
        ChargeableWeight:   chargeableWeight,
        CalculationDetails: details,
    }, nil
}

func calculateVolumeWeight(volume float64) float64 {
    // volume单位：m³
    // 转换为cm³再除以6000
    volumeCm3 := volume * 1000000
    return volumeCm3 / 6000 / 1000 // 转换为kg
}

func calculateBaseFreight(weight float64, config *model.CourierPrice) float64 {
    if weight <= config.FirstWeight {
        return config.FirstPrice
    }

    // 续重部分（向上取整）
    additionalWeight := math.Ceil(weight - config.FirstWeight)
    additionalFreight := additionalWeight * config.AdditionalPrice

    return config.FirstPrice + additionalFreight
}

func max(a, b float64) float64 {
    if a > b {
        return a
    }
    return b
}
```

### 3.3 价格配置表设计

```sql
CREATE TABLE courier_prices (
    id BIGSERIAL PRIMARY KEY,
    courier_company VARCHAR(50) NOT NULL UNIQUE,
    first_weight DECIMAL(10, 2) NOT NULL DEFAULT 1.0,
    first_price DECIMAL(10, 2) NOT NULL,
    additional_price DECIMAL(10, 2) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 初始化数据
INSERT INTO courier_prices (courier_company, first_price, additional_price)
VALUES
    ('顺丰速运', 15.00, 5.00),
    ('中通快递', 10.00, 3.00),
    ('圆通快递', 10.00, 3.00),
    ('韵达快递', 10.00, 3.00),
    ('申通快递', 10.00, 3.00),
    ('邮政EMS', 12.00, 4.00);
```

## 4. 滞留件处理机制

### 4.1 滞留判定规则

#### 4.1.1 滞留时间配置
```
正常保管期限：3天（72小时）
最大保管期限：7天（168小时）
提醒间隔：24小时
```

#### 4.1.2 滞留状态流转
```
包裹入库
   ↓
设置预计滞留时间 = 入库时间 + 3天
   ↓
定时任务扫描（每小时执行）
   ↓
当前时间 >= 预计滞留时间？
   ↓ 是
标记为滞留 + 创建滞留记录
   ↓
发送第1次提醒（短信/邮件）
   ↓
24小时后发送第2次提醒
   ↓
48小时后发送第3次提醒
   ↓
达到最大保管期限（7天）
   ↓
自动退回 + 计算滞留费用
```

### 4.2 定时任务实现

```go
type OverdueScanner struct {
    parcelRepo  repository.ParcelRepository
    overdueRepo repository.OverdueRecordRepository
    notifier    service.NotificationService
}

// ScanOverdueParcels 扫描滞留包裹（定时任务，每小时执行）
func (os *OverdueScanner) ScanOverdueParcels(ctx context.Context) error {
    // 1. 查询所有待取/已上架且超期的包裹
    now := time.Now()
    parcels, err := os.parcelRepo.FindByExpectedOverdueTime(ctx, now)
    if err != nil {
        return err
    }

    log.Info("Found %d overdue parcels", len(parcels))

    for _, parcel := range parcels {
        // 2. 创建滞留记录
        record, err := os.createOverdueRecord(ctx, parcel)
        if err != nil {
            log.Error("Failed to create overdue record: %v", err)
            continue
        }

        // 3. 更新包裹状态为滞留
        err = os.parcelRepo.UpdateStatus(ctx, parcel.ID, "overdue")
        if err != nil {
            log.Error("Failed to update parcel status: %v", err)
            continue
        }

        // 4. 发送滞留提醒
        err = os.sendOverdueReminder(ctx, parcel, record)
        if err != nil {
            log.Error("Failed to send reminder: %v", err)
        }
    }

    return nil
}

func (os *OverdueScanner) createOverdueRecord(ctx context.Context, parcel *model.Parcel) (*model.OverdueRecord, error) {
    record := &model.OverdueRecord{
        ParcelID:        parcel.ID,
        OverdueStartAt:  time.Now(),
        ReminderCount:   0,
        OverdueFee:      0,
        Status:          "pending",
    }

    return os.overdueRepo.Create(ctx, record)
}

func (os *OverdueScanner) sendOverdueReminder(ctx context.Context, parcel *model.Parcel, record *model.OverdueRecord) error {
    // 发送短信/邮件提醒
    message := fmt.Sprintf(
        "【校园驿站】尊敬的%s，您的包裹（取件码：%s）已滞留，请尽快取件。",
        parcel.RecipientName,
        parcel.PickupCode,
    )

    err := os.notifier.SendSMS(ctx, parcel.RecipientPhone, message)
    if err != nil {
        return err
    }

    // 更新提醒记录
    record.ReminderCount++
    record.LastReminderAt = time.Now()
    return os.overdueRepo.Update(ctx, record)
}

// ProcessMaxOverdueParcels 处理超过最大保管期限的包裹（每天执行）
func (os *OverdueScanner) ProcessMaxOverdueParcels(ctx context.Context) error {
    // 查询滞留超过7天的包裹
    maxOverdueDays := 7
    cutoffTime := time.Now().AddDate(0, 0, -maxOverdueDays)

    records, err := os.overdueRepo.FindByOverdueStartBefore(ctx, cutoffTime)
    if err != nil {
        return err
    }

    for _, record := range records {
        // 计算滞留费用
        overdueDays := int(time.Since(record.OverdueStartAt).Hours() / 24)
        extraDays := overdueDays - 3 // 超过3天的部分收费
        if extraDays > 0 {
            record.OverdueFee = float64(extraDays) * 1.0 // 1元/天
        }

        // 更新包裹状态为已退回
        parcel, err := os.parcelRepo.GetByID(ctx, record.ParcelID)
        if err != nil {
            continue
        }

        err = os.parcelRepo.UpdateStatus(ctx, parcel.ID, "returned")
        if err != nil {
            continue
        }

        // 更新滞留记录状态
        record.Status = "returned"
        os.overdueRepo.Update(ctx, record)

        // 发送退回通知
        os.sendReturnNotification(ctx, parcel, record)
    }

    return nil
}
```

### 4.3 定时任务配置

```go
// 使用gocron库配置定时任务
func SetupOverdueJobs(scanner *OverdueScanner) {
    s := gocron.NewScheduler(time.Local)

    // 每小时扫描滞留包裹
    s.Every(1).Hour().Do(func() {
        ctx := context.Background()
        err := scanner.ScanOverdueParcels(ctx)
        if err != nil {
            log.Error("Overdue scan failed: %v", err)
        }
    })

    // 每天凌晨1点处理超期退回
    s.Every(1).Day().At("01:00").Do(func() {
        ctx := context.Background()
        err := scanner.ProcessMaxOverdueParcels(ctx)
        if err != nil {
            log.Error("Max overdue process failed: %v", err)
        }
    })

    s.StartAsync()
}
```

## 5. 包裹状态流转控制

### 5.1 状态机设计

```go
// 包裹状态常量
const (
    StatusReceived       = "received"         // 已入库
    StatusShelved        = "shelved"          // 已上架
    StatusReadyForPickup = "ready_for_pickup" // 待取件
    StatusPickedUp       = "picked_up"        // 已取件
    StatusOverdue        = "overdue"          // 滞留
    StatusReturned       = "returned"         // 已退回
)

// 状态流转规则
var StatusTransitions = map[string][]string{
    StatusReceived: {StatusShelved},
    StatusShelved:  {StatusReadyForPickup, StatusOverdue},
    StatusReadyForPickup: {StatusPickedUp, StatusOverdue},
    StatusOverdue:  {StatusPickedUp, StatusReturned},
    StatusPickedUp: {}, // 终态
    StatusReturned: {}, // 终态
}

// 状态流转验证器
type StatusValidator struct{}

func (sv *StatusValidator) CanTransition(from, to string) bool {
    allowedStates, exists := StatusTransitions[from]
    if !exists {
        return false
    }

    for _, state := range allowedStates {
        if state == to {
            return true
        }
    }

    return false
}

func (sv *StatusValidator) ValidateTransition(from, to string) error {
    if !sv.CanTransition(from, to) {
        return fmt.Errorf("invalid status transition from %s to %s", from, to)
    }
    return nil
}
```

### 5.2 状态更新服务

```go
type ParcelStatusService struct {
    repo      repository.ParcelRepository
    validator *StatusValidator
    logger    *zap.Logger
}

func (pss *ParcelStatusService) UpdateStatus(ctx context.Context, parcelID int64, newStatus string) error {
    // 1. 查询当前包裹
    parcel, err := pss.repo.GetByID(ctx, parcelID)
    if err != nil {
        return err
    }

    // 2. 验证状态流转合法性
    err = pss.validator.ValidateTransition(parcel.Status, newStatus)
    if err != nil {
        return err
    }

    // 3. 更新状态和时间戳
    now := time.Now()
    updates := map[string]interface{}{
        "status":     newStatus,
        "updated_at": now,
    }

    switch newStatus {
    case StatusShelved:
        updates["shelved_at"] = now
    case StatusPickedUp:
        updates["picked_up_at"] = now
    }

    // 4. 执行更新
    err = pss.repo.Update(ctx, parcelID, updates)
    if err != nil {
        return err
    }

    // 5. 记录操作日志
    pss.logStatusChange(ctx, parcelID, parcel.Status, newStatus)

    return nil
}
```

## 6. 高性能查询优化

### 6.1 取件码查询优化

```go
// 使用唯一索引的精确查询
func (r *ParcelRepository) GetByPickupCode(ctx context.Context, pickupCode string) (*model.Parcel, error) {
    var parcel model.Parcel

    // 利用唯一索引，时间复杂度O(log n)
    err := r.db.WithContext(ctx).
        Where("pickup_code = ? AND deleted_at IS NULL", pickupCode).
        First(&parcel).Error

    if err != nil {
        return nil, err
    }

    return &parcel, nil
}
```

### 6.2 分页查询优化

#### 游标分页（Cursor Pagination）
适用于大数据量、实时数据的场景：

```go
type CursorPaginationParams struct {
    Cursor   int64  // 上次查询的最后一条记录ID
    PageSize int    // 每页数量
    Status   string // 状态过滤
}

func (r *ParcelRepository) ListByCursor(ctx context.Context, params CursorPaginationParams) ([]*model.Parcel, error) {
    var parcels []*model.Parcel

    query := r.db.WithContext(ctx).
        Where("deleted_at IS NULL")

    // 状态过滤
    if params.Status != "" {
        query = query.Where("status = ?", params.Status)
    }

    // 游标分页
    if params.Cursor > 0 {
        query = query.Where("id > ?", params.Cursor)
    }

    err := query.
        Order("id ASC").
        Limit(params.PageSize).
        Find(&parcels).Error

    return parcels, err
}
```

#### 索引覆盖优化
```sql
-- 创建覆盖索引
CREATE INDEX idx_parcels_status_id_covering
ON parcels(status, id)
INCLUDE (tracking_number, pickup_code, recipient_name, received_at)
WHERE deleted_at IS NULL;

-- 查询时只扫描索引，无需回表
EXPLAIN SELECT id, tracking_number, pickup_code, recipient_name, received_at
FROM parcels
WHERE status = 'ready_for_pickup' AND deleted_at IS NULL
ORDER BY id
LIMIT 20;
```

### 6.3 统计查询优化

#### 使用物化视图（Materialized View）
```sql
-- 创建包裹统计物化视图
CREATE MATERIALIZED VIEW mv_parcel_statistics AS
SELECT
    DATE(received_at) as stat_date,
    status,
    courier_company,
    COUNT(*) as parcel_count,
    AVG(EXTRACT(EPOCH FROM (picked_up_at - received_at))/3600) as avg_pickup_hours
FROM parcels
WHERE deleted_at IS NULL
GROUP BY DATE(received_at), status, courier_company;

-- 创建索引
CREATE INDEX idx_mv_parcel_stats_date ON mv_parcel_statistics(stat_date);

-- 定时刷新（每天凌晨）
REFRESH MATERIALIZED VIEW mv_parcel_statistics;
```

#### 使用缓存
```go
type StatisticsService struct {
    repo  repository.StatisticsRepository
    cache cache.Cache
}

func (ss *StatisticsService) GetDashboardStats(ctx context.Context) (*DashboardStats, error) {
    // 尝试从缓存获取
    cacheKey := "dashboard_stats"
    var stats DashboardStats

    err := ss.cache.Get(ctx, cacheKey, &stats)
    if err == nil {
        return &stats, nil
    }

    // 缓存未命中，从数据库查询
    stats, err = ss.repo.GetDashboardStats(ctx)
    if err != nil {
        return nil, err
    }

    // 写入缓存，TTL 5分钟
    ss.cache.Set(ctx, cacheKey, stats, 5*time.Minute)

    return &stats, nil
}
```

## 7. 事务管理

### 7.1 包裹取件事务

```go
func (ps *ParcelService) PickupParcel(ctx context.Context, pickupCode, phone string) error {
    // 使用事务保证数据一致性
    return ps.tm.Transaction(ctx, func(ctx context.Context) error {
        // 1. 查询并锁定包裹记录（FOR UPDATE）
        parcel, err := ps.repo.GetByPickupCodeForUpdate(ctx, pickupCode)
        if err != nil {
            return err
        }

        // 2. 验证手机号
        if parcel.RecipientPhone != phone {
            return errors.New("phone number mismatch")
        }

        // 3. 验证状态
        if parcel.Status != StatusReadyForPickup && parcel.Status != StatusOverdue {
            return errors.New("parcel not ready for pickup")
        }

        // 4. 更新包裹状态
        err = ps.repo.UpdateStatus(ctx, parcel.ID, StatusPickedUp)
        if err != nil {
            return err
        }

        // 5. 释放货架空间
        if parcel.ShelfID != nil {
            err = ps.shelfRepo.DecreaseCount(ctx, *parcel.ShelfID)
            if err != nil {
                return err
            }
        }

        // 6. 如果有滞留记录，更新状态
        if parcel.Status == StatusOverdue {
            err = ps.overdueRepo.UpdateStatusByParcelID(ctx, parcel.ID, "picked_up")
            if err != nil {
                return err
            }
        }

        // 7. 记录操作日志
        log := &model.OperationLog{
            OperatorID:    getUserIDFromCtx(ctx),
            OperationType: "parcel_picked_up",
            ObjectType:    "parcel",
            ObjectID:      parcel.ID,
            Description:   fmt.Sprintf("取件：%s", pickupCode),
            IPAddress:     getIPFromCtx(ctx),
        }
        err = ps.logRepo.Create(ctx, log)

        return err
    })
}
```

### 7.2 行级锁查询

```go
// FOR UPDATE锁定查询
func (r *ParcelRepository) GetByPickupCodeForUpdate(ctx context.Context, pickupCode string) (*model.Parcel, error) {
    var parcel model.Parcel

    err := r.db.WithContext(ctx).
        Clauses(clause.Locking{Strength: "UPDATE"}).
        Where("pickup_code = ? AND deleted_at IS NULL", pickupCode).
        First(&parcel).Error

    return &parcel, err
}
```

## 8. 并发控制

### 8.1 货架分配并发控制

使用乐观锁防止货架超分配：

```go
func (r *ShelfRepository) AllocateWithOptimisticLock(ctx context.Context, shelfID int64) error {
    // 使用乐观锁（版本号或更新时间）
    result := r.db.WithContext(ctx).
        Model(&model.Shelf{}).
        Where("id = ? AND current_count < capacity", shelfID).
        Update("current_count", gorm.Expr("current_count + 1"))

    if result.RowsAffected == 0 {
        return errors.New("shelf allocation failed: no space or concurrent update")
    }

    return result.Error
}
```

### 8.2 分布式锁（高并发场景）

```go
import "github.com/go-redsync/redsync/v4"

type ShelfAllocatorWithLock struct {
    allocator *ShelfAllocator
    mutex     *redsync.Mutex
}

func (sal *ShelfAllocatorWithLock) AllocateShelf(ctx context.Context, parcelID int64, size string) (*model.Shelf, error) {
    // 获取分布式锁
    lockKey := fmt.Sprintf("shelf_allocation:%s", size)
    mutex := sal.redsync.NewMutex(lockKey)

    err := mutex.Lock()
    if err != nil {
        return nil, err
    }
    defer mutex.Unlock()

    // 执行货架分配
    return sal.allocator.AllocateShelf(ctx, size)
}
```

## 9. 数据一致性保证

### 9.1 最终一致性
- 使用消息队列处理异步任务（如发送通知）
- 失败重试机制
- 幂等性设计

### 9.2 强一致性
- 关键业务使用数据库事务
- 行级锁保证并发安全
- 约束和触发器保证数据完整性

### 9.3 监控和告警
- 记录关键操作日志
- 监控异常事务
- 数据一致性定时校验

## 10. 总结

本设计文档涵盖了系统的核心功能实现细节：
1. **货架分配算法**：基于优先级的智能分配
2. **取件码生成**：唯一性和简洁性兼顾
3. **运费计算**：灵活的多维度计费
4. **滞留件处理**：自动化的定时任务机制
5. **状态流转**：严格的状态机控制
6. **性能优化**：索引、缓存、分页优化
7. **事务管理**：数据一致性保证
8. **并发控制**：乐观锁和分布式锁

这些设计为系统的高性能、高可用性和数据一致性提供了坚实的基础。
