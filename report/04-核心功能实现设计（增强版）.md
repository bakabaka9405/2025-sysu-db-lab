# 核心功能实现设计（数据库高级特性集成版）

## 前言

本文档展示如何在Go应用层（GORM）中充分利用PostgreSQL的高级特性实现核心业务功能：

- ✅ **调用存储过程**：将复杂业务逻辑下沉到数据库层
- ✅ **使用触发器**：自动维护数据一致性，减少应用层代码
- ✅ **查询视图**：简化复杂查询，提升开发效率
- ✅ **事务控制**：保证ACID特性，处理并发冲突
- ✅ **性能优化**：利用索引、分区、缓存提升查询性能

---

## 1. 包裹入库功能（调用存储过程）

### 1.1 功能设计

包裹入库是系统的核心功能，涉及多个步骤：
1. 验证快递单号唯一性
2. 调用货架分配算法
3. 生成唯一取件码
4. 插入包裹记录
5. 自动计算预计滞留时间（触发器）
6. 自动更新货架占用数（触发器）

**设计思路**：将整个流程封装为PostgreSQL存储过程，应用层只需调用一次。

### 1.2 数据库层实现（存储过程）

```sql
-- 存储过程已在 02-数据库设计.md 中定义
-- 函数签名：
-- receive_parcel(
--     tracking_number, recipient_name, recipient_phone,
--     recipient_id_card, courier_company, size, weight, notes
-- ) RETURNS (parcel_id, pickup_code, shelf_id, shelf_code)
```

### 1.3 应用层实现（GORM调用）

#### Repository层
```go
package repository

import (
    "context"
    "gorm.io/gorm"
)

type ParcelRepository struct {
    db *gorm.DB
}

type ReceiveParcelParams struct {
    TrackingNumber  string
    RecipientName   string
    RecipientPhone  string
    RecipientIDCard string
    CourierCompany  string
    Size            string  // small, medium, large
    Weight          float64
    Notes           string
}

type ReceiveParcelResult struct {
    ParcelID   int64  `gorm:"column:parcel_id"`
    PickupCode string `gorm:"column:pickup_code"`
    ShelfID    int64  `gorm:"column:shelf_id"`
    ShelfCode  string `gorm:"column:shelf_code"`
}

// ReceiveParcel 调用数据库存储过程完成包裹入库
func (r *ParcelRepository) ReceiveParcel(ctx context.Context, params *ReceiveParcelParams) (*ReceiveParcelResult, error) {
    var result ReceiveParcelResult

    // 调用PostgreSQL存储过程
    err := r.db.WithContext(ctx).
        Raw(`
            SELECT * FROM receive_parcel(
                $1::VARCHAR,  -- tracking_number
                $2::VARCHAR,  -- recipient_name
                $3::VARCHAR,  -- recipient_phone
                $4::VARCHAR,  -- recipient_id_card
                $5::VARCHAR,  -- courier_company
                $6::VARCHAR,  -- size
                $7::DECIMAL,  -- weight
                $8::TEXT      -- notes
            )
        `,
            params.TrackingNumber,
            params.RecipientName,
            params.RecipientPhone,
            params.RecipientIDCard,
            params.CourierCompany,
            params.Size,
            params.Weight,
            params.Notes,
        ).
        Scan(&result).Error

    if err != nil {
        return nil, err
    }

    return &result, nil
}
```

#### Service层
```go
package service

import (
    "context"
    "fmt"
)

type ParcelService struct {
    repo   repository.ParcelRepository
    logger *zap.Logger
}

// ReceiveParcel 包裹入库服务
func (s *ParcelService) ReceiveParcel(ctx context.Context, req *ReceiveParcelRequest) (*ReceiveParcelResponse, error) {
    // 参数验证
    if err := s.validateReceiveRequest(req); err != nil {
        return nil, err
    }

    // 调用存储过程（数据库层完成所有业务逻辑）
    result, err := s.repo.ReceiveParcel(ctx, &repository.ReceiveParcelParams{
        TrackingNumber:  req.TrackingNumber,
        RecipientName:   req.RecipientName,
        RecipientPhone:  req.RecipientPhone,
        RecipientIDCard: req.RecipientIDCard,
        CourierCompany:  req.CourierCompany,
        Size:            req.Size,
        Weight:          req.Weight,
        Notes:           req.Notes,
    })

    if err != nil {
        s.logger.Error("包裹入库失败", zap.Error(err), zap.String("tracking", req.TrackingNumber))
        return nil, fmt.Errorf("包裹入库失败: %w", err)
    }

    // 异步发送取件通知（不影响主流程）
    go s.sendPickupNotification(ctx, result.ParcelID, req.RecipientPhone, result.PickupCode)

    s.logger.Info("包裹入库成功",
        zap.Int64("parcel_id", result.ParcelID),
        zap.String("pickup_code", result.PickupCode),
        zap.String("shelf_code", result.ShelfCode),
    )

    return &ReceiveParcelResponse{
        ParcelID:   result.ParcelID,
        PickupCode: result.PickupCode,
        ShelfCode:  result.ShelfCode,
    }, nil
}
```

### 1.4 优势分析

✅ **业务逻辑下沉**：复杂的入库流程在数据库层完成，减少网络往返
✅ **原子性保证**：存储过程自带事务，保证数据一致性
✅ **触发器自动化**：货架计数、滞留时间自动计算，无需应用层干预
✅ **性能优化**：一次数据库调用完成多个操作，减少延迟

---

## 2. 包裹取件功能（事务控制 + 行级锁）

### 2.1 功能设计

包裹取件需要处理并发场景：
1. 验证取件码和手机号
2. 检查包裹状态
3. 更新包裹状态为已取件
4. 释放货架空间（触发器自动）
5. 更新滞留记录状态（如果有）
6. 记录操作日志（触发器自动）

**并发问题**：多个用户可能同时输入相同取件码

**解决方案**：使用行级锁（FOR UPDATE）+ 存储过程

### 2.2 数据库层实现（存储过程 + 行级锁）

```sql
-- 存储过程已在 02-数据库设计.md 中定义
-- pickup_parcel(pickup_code, recipient_phone)
-- 内部使用 FOR UPDATE 行级锁
```

### 2.3 应用层实现

#### Repository层
```go
type PickupParcelResult struct {
    Success        bool   `gorm:"column:success"`
    Message        string `gorm:"column:message"`
    ParcelID       *int64 `gorm:"column:parcel_id"`
    TrackingNumber *string `gorm:"column:tracking_number"`
}

// PickupParcel 调用存储过程完成包裹取件（带行级锁）
func (r *ParcelRepository) PickupParcel(ctx context.Context, pickupCode, phone string) (*PickupParcelResult, error) {
    var result PickupParcelResult

    err := r.db.WithContext(ctx).
        Raw(`SELECT * FROM pickup_parcel($1::VARCHAR, $2::VARCHAR)`, pickupCode, phone).
        Scan(&result).Error

    if err != nil {
        return nil, err
    }

    return &result, nil
}
```

#### Service层
```go
func (s *ParcelService) PickupParcel(ctx context.Context, pickupCode, phone string) error {
    // 调用存储过程（包含事务和锁控制）
    result, err := s.repo.PickupParcel(ctx, pickupCode, phone)
    if err != nil {
        return fmt.Errorf("取件失败: %w", err)
    }

    if !result.Success {
        return fmt.Errorf("取件失败: %s", result.Message)
    }

    s.logger.Info("取件成功",
        zap.Int64("parcel_id", *result.ParcelID),
        zap.String("tracking", *result.TrackingNumber),
    )

    return nil
}
```

### 2.4 并发控制说明

```sql
-- 存储过程中的关键代码
SELECT ... FROM parcels WHERE pickup_code = p_pickup_code
FOR UPDATE;  -- 行级排他锁

-- 并发场景：
-- 事务A: BEGIN -> SELECT FOR UPDATE（获得锁）-> UPDATE -> COMMIT（释放锁）
-- 事务B: BEGIN -> SELECT FOR UPDATE（等待A释放锁）-> 发现已被取走 -> 返回错误
```

✅ **防止重复取件**：FOR UPDATE确保同一时间只有一个事务能修改包裹
✅ **ACID保证**：存储过程内所有操作要么全成功，要么全失败
✅ **触发器联动**：状态更新触发货架计数减少、日志记录

---

## 3. 运费计算功能（调用函数）

### 3.1 功能设计

运费计算逻辑复杂：
1. 查询快递公司价格配置
2. 计算体积重量
3. 确定计费重量
4. 计算基础运费（首重+续重）
5. 计算附加费用（保价、签收回单）

**设计思路**：封装为PostgreSQL函数，确保计算逻辑一致性

### 3.2 数据库层实现（函数）

```sql
-- 函数已在 02-数据库设计.md 中定义
-- calculate_freight(courier_company, weight, volume, declared_value, require_receipt)
-- RETURNS TABLE(total_freight, base_freight, insurance_fee, receipt_fee, chargeable_weight)
```

### 3.3 应用层实现

#### Repository层
```go
type FreightCalculationParams struct {
    CourierCompany string
    Weight         float64
    Volume         *float64  // 可选
    DeclaredValue  *float64  // 可选
    RequireReceipt bool
}

type FreightCalculationResult struct {
    TotalFreight      float64 `gorm:"column:total_freight"`
    BaseFreight       float64 `gorm:"column:base_freight"`
    InsuranceFee      float64 `gorm:"column:insurance_fee"`
    ReceiptFee        float64 `gorm:"column:receipt_fee"`
    ChargeableWeight  float64 `gorm:"column:chargeable_weight"`
}

// CalculateFreight 调用数据库函数计算运费
func (r *ShipmentRepository) CalculateFreight(ctx context.Context, params *FreightCalculationParams) (*FreightCalculationResult, error) {
    var result FreightCalculationResult

    // 处理可选参数
    volume := 0.0
    if params.Volume != nil {
        volume = *params.Volume
    }

    declaredValue := 0.0
    if params.DeclaredValue != nil {
        declaredValue = *params.DeclaredValue
    }

    err := r.db.WithContext(ctx).
        Raw(`
            SELECT * FROM calculate_freight(
                $1::VARCHAR,
                $2::DECIMAL,
                $3::DECIMAL,
                $4::DECIMAL,
                $5::BOOLEAN
            )
        `,
            params.CourierCompany,
            params.Weight,
            volume,
            declaredValue,
            params.RequireReceipt,
        ).
        Scan(&result).Error

    return &result, err
}
```

#### Service层
```go
func (s *ShipmentService) CalculateFreight(ctx context.Context, req *CalculateFreightRequest) (*FreightResult, error) {
    // 调用数据库函数
    result, err := s.repo.CalculateFreight(ctx, &repository.FreightCalculationParams{
        CourierCompany: req.CourierCompany,
        Weight:         req.Weight,
        Volume:         req.Volume,
        DeclaredValue:  req.DeclaredValue,
        RequireReceipt: req.RequireReceipt,
    })

    if err != nil {
        return nil, fmt.Errorf("运费计算失败: %w", err)
    }

    return &FreightResult{
        TotalFreight:     result.TotalFreight,
        BaseFreight:      result.BaseFreight,
        InsuranceFee:     result.InsuranceFee,
        ReceiptFee:       result.ReceiptFee,
        ChargeableWeight: result.ChargeableWeight,
        Details: fmt.Sprintf(
            "计费重量: %.2fkg, 基础运费: %.2f元, 保价费: %.2f元, 签收回单: %.2f元",
            result.ChargeableWeight,
            result.BaseFreight,
            result.InsuranceFee,
            result.ReceiptFee,
        ),
    }, nil
}
```

### 3.4 优势分析

✅ **业务逻辑集中**：价格配置和计算逻辑在数据库层，便于维护
✅ **一致性保证**：前后端、API、后台任务都使用同一个计算函数
✅ **性能优化**：数据库内计算，减少数据传输
✅ **可测试性**：可以直接在数据库中测试计算逻辑

---

## 4. 统计查询功能（使用视图）

### 4.1 功能设计

仪表盘需要展示多项统计数据：
- 今日入库/取件/滞留数量
- 待取件/滞留件总数
- 货架利用率
- 近期趋势

**设计思路**：使用视图简化复杂查询，提升查询性能

### 4.2 数据库层实现（视图）

```sql
-- 视图已在 02-数据库设计.md 中定义
-- v_daily_dashboard: 每日运营仪表盘视图
-- v_shelf_utilization: 货架利用率视图
-- v_user_parcels: 用户包裹视图（带脱敏）
```

### 4.3 应用层实现

#### Repository层
```go
// 使用视图查询仪表盘数据
type DashboardStats struct {
    StatDate          time.Time `gorm:"column:stat_date"`
    TodayReceived     int       `gorm:"column:today_received"`
    TodayPickedUp     int       `gorm:"column:today_picked_up"`
    TodayOverdue      int       `gorm:"column:today_overdue"`
    TotalPendingPickup int      `gorm:"column:total_pending_pickup"`
    TotalOverdue      int       `gorm:"column:total_overdue"`
    TotalCapacity     int       `gorm:"column:total_capacity"`
    TotalUsed         int       `gorm:"column:total_used"`
    UtilizationRate   float64   `gorm:"column:utilization_rate"`
}

func (r *StatisticsRepository) GetDashboardStats(ctx context.Context) (*DashboardStats, error) {
    var stats DashboardStats

    // 直接查询视图，一条SQL获取所有数据
    err := r.db.WithContext(ctx).
        Table("v_daily_dashboard").
        First(&stats).Error

    return &stats, err
}

// 查询货架利用率（使用视图）
type ShelfUtilization struct {
    ID              int64   `gorm:"column:id"`
    ShelfCode       string  `gorm:"column:shelf_code"`
    Area            string  `gorm:"column:area"`
    Type            string  `gorm:"column:type"`
    Capacity        int     `gorm:"column:capacity"`
    CurrentCount    int     `gorm:"column:current_count"`
    UtilizationRate float64 `gorm:"column:utilization_rate"`
    LoadLevel       string  `gorm:"column:load_level"` // empty, low, medium, high, full
}

func (r *ShelfRepository) GetShelfUtilization(ctx context.Context, area string) ([]ShelfUtilization, error) {
    var utilizations []ShelfUtilization

    query := r.db.WithContext(ctx).Table("v_shelf_utilization")

    if area != "" {
        query = query.Where("area = ?", area)
    }

    err := query.Order("utilization_rate DESC").Find(&utilizations).Error

    return utilizations, err
}
```

#### Service层（带缓存）
```go
import "github.com/redis/go-redis/v9"

func (s *StatisticsService) GetDashboardStats(ctx context.Context) (*DashboardStats, error) {
    cacheKey := "dashboard:stats"

    // 1. 尝试从缓存获取
    var cached DashboardStats
    err := s.cache.Get(ctx, cacheKey, &cached)
    if err == nil {
        return &cached, nil
    }

    // 2. 缓存未命中，查询视图
    stats, err := s.repo.GetDashboardStats(ctx)
    if err != nil {
        return nil, err
    }

    // 3. 写入缓存（TTL 5分钟）
    s.cache.Set(ctx, cacheKey, stats, 5*time.Minute)

    return stats, nil
}
```

### 4.4 优势分析

✅ **查询简化**：复杂的统计查询封装为视图，应用层代码简洁
✅ **性能提升**：视图可以结合索引优化查询计划
✅ **数据安全**：脱敏视图避免敏感信息泄露
✅ **缓存友好**：视图结果可以缓存，进一步提升性能

---

## 5. 滞留件处理（定时任务 + 触发器）

### 5.1 功能设计

滞留件处理流程：
1. 定时扫描超期包裹（每小时）
2. 创建滞留记录
3. 更新包裹状态为滞留
4. 发送滞留提醒
5. 超期退回处理（每天）

**设计思路**：结合定时任务、视图查询、触发器联动

### 5.2 数据库层实现（视图 + 函数）

```sql
-- 待处理滞留件视图（已在02中定义）
CREATE VIEW v_pending_overdue_parcels AS ...

-- 滞留费用计算函数（已在02中定义）
CREATE FUNCTION calculate_overdue_fee(overdue_start_at) RETURNS DECIMAL ...
```

### 5.3 应用层实现（定时任务）

#### Repository层
```go
// 使用视图查询待处理滞留件
type PendingOverdueParcel struct {
    ParcelID           int64     `gorm:"column:parcel_id"`
    TrackingNumber     string    `gorm:"column:tracking_number"`
    PickupCode         string    `gorm:"column:pickup_code"`
    RecipientName      string    `gorm:"column:recipient_name"`
    RecipientPhone     string    `gorm:"column:recipient_phone"`
    ShelfCode          string    `gorm:"column:shelf_code"`
    ReceivedAt         time.Time `gorm:"column:received_at"`
    ExpectedOverdueAt  time.Time `gorm:"column:expected_overdue_at"`
    OverdueDays        int       `gorm:"column:overdue_days"`
    ReminderCount      int       `gorm:"column:reminder_count"`
    LastReminderAt     *time.Time `gorm:"column:last_reminder_at"`
    CurrentOverdueFee  float64   `gorm:"column:current_overdue_fee"` // 视图中调用函数计算
}

func (r *ParcelRepository) GetPendingOverdueParcels(ctx context.Context) ([]PendingOverdueParcel, error) {
    var parcels []PendingOverdueParcel

    // 查询视图（视图内部自动调用calculate_overdue_fee函数）
    err := r.db.WithContext(ctx).
        Table("v_pending_overdue_parcels").
        Find(&parcels).Error

    return parcels, err
}

// 查询需要发送提醒的滞留件（24小时未提醒）
func (r *ParcelRepository) GetOverdueParcelsForReminder(ctx context.Context) ([]PendingOverdueParcel, error) {
    var parcels []PendingOverdueParcel

    err := r.db.WithContext(ctx).
        Table("v_pending_overdue_parcels").
        Where("last_reminder_at IS NULL OR last_reminder_at < ?", time.Now().Add(-24*time.Hour)).
        Find(&parcels).Error

    return parcels, err
}
```

#### Job层（定时任务）
```go
package job

import (
    "github.com/go-co-op/gocron"
    "time"
)

type OverdueScanner struct {
    repo      repository.ParcelRepository
    overdueRepo repository.OverdueRecordRepository
    notifier  service.NotificationService
    logger    *zap.Logger
}

// ScanOverdueParcels 扫描滞留包裹（每小时执行）
func (s *OverdueScanner) ScanOverdueParcels(ctx context.Context) error {
    s.logger.Info("开始扫描滞留包裹")

    // 查询待处理滞留件（使用视图）
    parcels, err := s.repo.GetPendingOverdueParcels(ctx)
    if err != nil {
        return fmt.Errorf("查询滞留包裹失败: %w", err)
    }

    s.logger.Info("发现滞留包裹", zap.Int("count", len(parcels)))

    for _, parcel := range parcels {
        // 发送提醒（需要提醒的包裹）
        if s.shouldSendReminder(&parcel) {
            if err := s.sendReminder(ctx, &parcel); err != nil {
                s.logger.Error("发送提醒失败",
                    zap.Int64("parcel_id", parcel.ParcelID),
                    zap.Error(err),
                )
                continue
            }
        }

        // 超期退回（超过7天）
        if parcel.OverdueDays >= 7 {
            if err := s.returnParcel(ctx, &parcel); err != nil {
                s.logger.Error("退回包裹失败",
                    zap.Int64("parcel_id", parcel.ParcelID),
                    zap.Error(err),
                )
            }
        }
    }

    return nil
}

func (s *OverdueScanner) shouldSendReminder(parcel *PendingOverdueParcel) bool {
    // 从未提醒过，或距离上次提醒超过24小时
    if parcel.LastReminderAt == nil {
        return true
    }
    return time.Since(*parcel.LastReminderAt) >= 24*time.Hour
}

func (s *OverdueScanner) sendReminder(ctx context.Context, parcel *PendingOverdueParcel) error {
    // 发送短信提醒
    message := fmt.Sprintf(
        "【校园驿站】尊敬的%s，您的包裹（取件码：%s）已滞留%d天，请尽快取件。当前滞留费用：%.2f元",
        parcel.RecipientName,
        parcel.PickupCode,
        parcel.OverdueDays,
        parcel.CurrentOverdueFee,
    )

    if err := s.notifier.SendSMS(ctx, parcel.RecipientPhone, message); err != nil {
        return err
    }

    // 更新提醒记录
    return s.overdueRepo.UpdateReminderInfo(ctx, parcel.ParcelID)
}

func (s *OverdueScanner) returnParcel(ctx context.Context, parcel *PendingOverdueParcel) error {
    s.logger.Info("开始退回包裹",
        zap.Int64("parcel_id", parcel.ParcelID),
        zap.Int("overdue_days", parcel.OverdueDays),
    )

    // 使用事务更新包裹和滞留记录状态
    return s.repo.Transaction(ctx, func(tx context.Context) error {
        // 更新包裹状态为已退回
        if err := s.repo.UpdateStatus(tx, parcel.ParcelID, "returned"); err != nil {
            return err
        }

        // 更新滞留记录状态
        if err := s.overdueRepo.MarkAsReturned(tx, parcel.ParcelID, parcel.CurrentOverdueFee); err != nil {
            return err
        }

        // 发送退回通知
        go s.sendReturnNotification(context.Background(), parcel)

        return nil
    })
}

// SetupJobs 配置定时任务
func SetupJobs(scanner *OverdueScanner) *gocron.Scheduler {
    s := gocron.NewScheduler(time.Local)

    // 每小时扫描滞留包裹
    s.Every(1).Hour().Do(func() {
        ctx := context.Background()
        if err := scanner.ScanOverdueParcels(ctx); err != nil {
            scanner.logger.Error("滞留扫描失败", zap.Error(err))
        }
    })

    s.StartAsync()
    return s
}
```

### 5.4 优势分析

✅ **视图简化查询**：v_pending_overdue_parcels 自动计算滞留费用
✅ **函数保证一致性**：calculate_overdue_fee 确保计费逻辑统一
✅ **触发器自动联动**：包裹状态更新自动影响货架计数
✅ **定时任务自动化**：无需人工干预，系统自动处理

---

## 6. 高性能查询优化实践

### 6.1 包裹查询（利用索引）

#### 取件码查询（唯一索引）
```go
// 使用唯一索引，O(log n)复杂度
func (r *ParcelRepository) GetByPickupCode(ctx context.Context, pickupCode string) (*model.Parcel, error) {
    var parcel model.Parcel

    // PostgreSQL会自动使用 idx_parcels_pickup_code_active 部分索引
    err := r.db.WithContext(ctx).
        Where("pickup_code = ? AND deleted_at IS NULL", pickupCode).
        First(&parcel).Error

    return &parcel, err
}
```

生成的SQL：
```sql
SELECT * FROM parcels
WHERE pickup_code = 'A12B45' AND deleted_at IS NULL;
-- 使用索引：idx_parcels_pickup_code_active (Unique Scan)
```

#### 手机号查询（复合索引）
```go
// 使用复合索引 idx_parcels_phone_status
func (r *ParcelRepository) GetUserActiveParcels(ctx context.Context, phone string) ([]model.Parcel, error) {
    var parcels []model.Parcel

    // 使用复合索引 (recipient_phone, status, received_at)
    err := r.db.WithContext(ctx).
        Where("recipient_phone = ? AND status IN (?, ?, ?) AND deleted_at IS NULL",
            phone, "ready_for_pickup", "shelved", "overdue").
        Order("received_at DESC").
        Find(&parcels).Error

    return parcels, err
}
```

生成的SQL：
```sql
SELECT * FROM parcels
WHERE recipient_phone = '13800138000'
  AND status IN ('ready_for_pickup', 'shelved', 'overdue')
  AND deleted_at IS NULL
ORDER BY received_at DESC;
-- 使用索引：idx_parcels_phone_status (Index Scan)
```

### 6.2 分页查询优化（游标分页）

#### 传统OFFSET分页（慢）
```go
// ❌ 不推荐：OFFSET在大数据量时性能差
func (r *ParcelRepository) ListWithOffset(ctx context.Context, page, pageSize int) ([]model.Parcel, error) {
    var parcels []model.Parcel

    offset := (page - 1) * pageSize

    err := r.db.WithContext(ctx).
        Where("deleted_at IS NULL").
        Order("id DESC").
        Offset(offset).
        Limit(pageSize).
        Find(&parcels).Error

    return parcels, err
}
```

#### 游标分页（快）
```go
// ✅ 推荐：使用游标分页，性能稳定
func (r *ParcelRepository) ListWithCursor(ctx context.Context, cursor int64, pageSize int) ([]model.Parcel, error) {
    var parcels []model.Parcel

    query := r.db.WithContext(ctx).
        Where("deleted_at IS NULL")

    if cursor > 0 {
        query = query.Where("id > ?", cursor)
    }

    err := query.
        Order("id ASC").
        Limit(pageSize).
        Find(&parcels).Error

    return parcels, err
}
```

性能对比：
```
传统分页 (OFFSET 10000):  ~500ms  （需要扫描前10000条）
游标分页 (cursor):          ~10ms  （直接从游标位置开始）
```

### 6.3 聚合查询优化（物化视图）

#### 慢查询（实时聚合）
```go
// ❌ 慢：每次都实时聚合
func (r *StatisticsRepository) GetMonthlyStatsSlow(ctx context.Context, month time.Time) (*MonthlyStats, error) {
    var stats MonthlyStats

    err := r.db.WithContext(ctx).
        Model(&model.Parcel{}).
        Select(`
            DATE_TRUNC('month', received_at) as month,
            COUNT(*) as total_parcels,
            COUNT(*) FILTER (WHERE status = 'picked_up') as picked_up_count,
            AVG(EXTRACT(EPOCH FROM (picked_up_at - received_at)) / 3600) as avg_pickup_hours
        `).
        Where("DATE_TRUNC('month', received_at) = ? AND deleted_at IS NULL", month).
        Group("DATE_TRUNC('month', received_at)").
        Scan(&stats).Error

    return &stats, err
}
```

#### 快查询（物化视图）
```go
// ✅ 快：查询预计算的物化视图
func (r *StatisticsRepository) GetMonthlyStats(ctx context.Context, month time.Time) (*MonthlyStats, error) {
    var stats MonthlyStats

    err := r.db.WithContext(ctx).
        Table("mv_monthly_statistics").
        Where("month = ?", month).
        First(&stats).Error

    return &stats, err
}

// 定时刷新物化视图（每天凌晨）
func (r *StatisticsRepository) RefreshMonthlyStats(ctx context.Context) error {
    return r.db.WithContext(ctx).
        Exec("REFRESH MATERIALIZED VIEW CONCURRENTLY mv_monthly_statistics").Error
}
```

### 6.4 全文搜索（GIN索引）

```go
// 使用PostgreSQL全文搜索（GIN索引）
func (r *ParcelRepository) SearchByNotes(ctx context.Context, keyword string) ([]model.Parcel, error) {
    var parcels []model.Parcel

    // 使用GIN索引进行全文搜索
    err := r.db.WithContext(ctx).
        Where("notes_tsv @@ to_tsquery('chinese', ?)", keyword).
        Find(&parcels).Error

    return parcels, err
}
```

---

## 7. 事务管理最佳实践

### 7.1 Service层事务（GORM Transaction Manager）

```go
type TransactionManager interface {
    Transaction(ctx context.Context, fn func(ctx context.Context) error) error
}

type transactionManager struct {
    db *gorm.DB
}

func (tm *transactionManager) Transaction(ctx context.Context, fn func(context.Context) error) error {
    return tm.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // 创建带有事务的新context
        txCtx := context.WithValue(ctx, "tx", tx)
        return fn(txCtx)
    })
}

// Service中使用
func (s *ParcelService) ComplexOperation(ctx context.Context, req *Request) error {
    return s.tm.Transaction(ctx, func(ctx context.Context) error {
        // 操作1：创建包裹
        parcel, err := s.parcelRepo.Create(ctx, ...)
        if err != nil {
            return err
        }

        // 操作2：更新货架
        err = s.shelfRepo.UpdateCount(ctx, shelfID, 1)
        if err != nil {
            return err // 自动回滚
        }

        // 操作3：记录日志
        err = s.logRepo.Create(ctx, ...)
        return err
    })
}
```

### 7.2 设置隔离级别

```go
func (s *ParcelService) PickupWithSerializable(ctx context.Context, pickupCode string) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 设置SERIALIZABLE隔离级别
        if err := tx.Exec("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE").Error; err != nil {
            return err
        }

        // 业务逻辑
        var parcel model.Parcel
        if err := tx.Where("pickup_code = ?", pickupCode).First(&parcel).Error; err != nil {
            return err
        }

        parcel.Status = "picked_up"
        return tx.Save(&parcel).Error
    })
}
```

### 7.3 使用保存点

```go
func (s *ParcelService) ComplexOperationWithSavepoint(ctx context.Context) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 步骤1
        if err := s.step1(tx); err != nil {
            return err
        }

        // 创建保存点
        tx.SavePoint("sp1")

        // 步骤2（可能失败）
        if err := s.step2(tx); err != nil {
            // 回滚到保存点
            tx.RollbackTo("sp1")
            // 使用替代方案
            if err := s.step2Alternative(tx); err != nil {
                return err
            }
        }

        // 步骤3
        return s.step3(tx)
    })
}
```

---

## 8. 性能监控和调优

### 8.1 慢查询监控

```go
// GORM回调记录慢查询
func SlowQueryLogger(db *gorm.DB) {
    db.Callback().Query().After("gorm:query").Register("slow_query_logger", func(db *gorm.DB) {
        elapsed := time.Since(db.Statement.StartAt)

        if elapsed > 100*time.Millisecond {
            sql := db.Dialector.Explain(db.Statement.SQL.String(), db.Statement.Vars...)
            logger.Warn("慢查询检测",
                zap.Duration("elapsed", elapsed),
                zap.String("sql", sql),
            )
        }
    })
}
```

### 8.2 使用EXPLAIN分析

```go
func (r *ParcelRepository) AnalyzeQuery(ctx context.Context, query string, args ...interface{}) {
    var result []map[string]interface{}

    explainSQL := "EXPLAIN (ANALYZE, BUFFERS, VERBOSE) " + query

    r.db.WithContext(ctx).Raw(explainSQL, args...).Scan(&result)

    for _, row := range result {
        fmt.Printf("%v\n", row)
    }
}
```

---

## 9. 总结

本设计充分展示了如何在Go应用层（GORM）中发挥PostgreSQL高级特性的优势：

### 9.1 核心设计模式

| 功能模块 | 数据库特性 | 应用层技术 | 优势 |
|---------|-----------|-----------|------|
| 包裹入库 | 存储过程 + 触发器 | GORM Raw SQL | 业务下沉、原子性 |
| 包裹取件 | 存储过程 + 行级锁 | 事务管理 | 并发安全 |
| 运费计算 | 函数 | 调用封装 | 逻辑一致性 |
| 统计查询 | 视图 + 物化视图 | 缓存策略 | 性能优化 |
| 滞留处理 | 视图 + 函数 + 触发器 | 定时任务 | 自动化 |

### 9.2 性能优化总结

✅ **索引策略**：部分索引、复合索引、表达式索引、GIN/BRIN索引
✅ **查询优化**：游标分页、物化视图、全文搜索
✅ **业务下沉**：存储过程减少网络往返
✅ **自动化**：触发器自动维护数据一致性

### 9.3 开发效率

✅ **GORM便利性**：ORM简化CRUD操作
✅ **PostgreSQL强大性**：高级特性保证性能和数据完整性
✅ **最佳实践**：简单查询用GORM，复杂业务用存储过程

这种设计既保持了现代应用开发的便捷性，又充分发挥了数据库系统的专业能力，是GORM与PostgreSQL协同的最佳实践。
