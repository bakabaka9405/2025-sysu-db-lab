# 数据库设计（PostgreSQL高级特性增强版）

## 前言

本数据库设计在满足3NF范式的基础上，**深度应用PostgreSQL的高级特性**，包括：
- ✅ **触发器**：自动维护数据一致性、业务逻辑自动化
- ✅ **存储过程/函数**：封装复杂业务逻辑
- ✅ **视图**：简化复杂查询、提供数据安全视角
- ✅ **事务控制**：保证ACID特性、处理并发
- ✅ **高级索引**：部分索引、表达式索引、GIN/BRIN索引
- ✅ **完整性约束**：CHECK、EXCLUDE、延迟约束

虽然应用层使用GORM简化操作，但**数据库层面充分发挥PostgreSQL的强大功能**，实现业务逻辑下沉、性能优化和数据安全。

---

## 1. 概念结构设计（E-R图）

### 1.1 核心实体

#### 用户实体（User）
- **属性**：用户ID、用户名、密码、真实姓名、手机号、身份证号、邮箱、角色、创建时间、更新时间

#### 包裹实体（Parcel）
- **属性**：包裹ID、快递单号、取件码、收件人信息、快递公司、包裹大小、重量、状态、货架ID、各阶段时间戳

#### 货架实体（Shelf）
- **属性**：货架ID、货架编号、区域、层号、列号、类型、容量、当前占用数、状态

#### 寄件实体（Shipment）
- **属性**：寄件ID、寄件单号、寄件人/收件人信息、快递公司、重量、体积、运费、状态

#### 滞留记录实体（OverdueRecord）
- **属性**：记录ID、包裹ID、滞留时间、提醒次数、滞留费用、处理状态

#### 操作日志实体（OperationLog）
- **属性**：日志ID、操作人ID、操作类型、操作对象、描述、IP地址、操作时间

### 1.2 实体关系

```
User (1) ←→ (N) Parcel        收件关系
Shelf (1) ←→ (N) Parcel       存放关系
User (1) ←→ (N) Shipment      寄件关系
Parcel (1) ←→ (1) OverdueRecord   滞留关系
User (1) ←→ (N) OperationLog  操作关系
```

---

## 2. 逻辑结构设计（关系模式 - 3NF）

### 2.1 关系模式定义

#### User（用户表）
```
User (
    id [PK],
    username [UNIQUE],
    password,
    real_name,
    phone [UNIQUE],
    id_card [UNIQUE],
    email,
    role,
    created_at,
    updated_at,
    deleted_at
)
```

#### Parcel（包裹表）
```
Parcel (
    id [PK],
    tracking_number [UNIQUE],
    pickup_code [UNIQUE],
    recipient_name,
    recipient_phone,
    recipient_id_card,
    courier_company,
    size,
    weight,
    status,
    shelf_id [FK -> Shelf.id],
    received_at,
    shelved_at,
    picked_up_at,
    expected_overdue_at,
    notes,
    created_at,
    updated_at,
    deleted_at
)
```

#### Shelf（货架表）
```
Shelf (
    id [PK],
    shelf_code [UNIQUE],
    area,
    floor,
    column,
    type,
    capacity,
    current_count,
    status,
    created_at,
    updated_at,
    deleted_at
)
```

**规范化分析**：
- 所有表满足 **1NF**（属性原子性）
- 所有表满足 **2NF**（消除部分依赖）
- 所有表满足 **3NF**（消除传递依赖）
- 大部分表满足 **BCNF**（决定因素都是候选键）

---

## 3. 物理结构设计（PostgreSQL实现）

### 3.1 表结构与约束

#### 用户表（完整约束示例）
```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    real_name VARCHAR(100),
    phone VARCHAR(20) NOT NULL UNIQUE,
    id_card VARCHAR(18) UNIQUE,
    email VARCHAR(100),
    role VARCHAR(20) NOT NULL DEFAULT 'user',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,

    -- CHECK约束
    CONSTRAINT chk_username_length CHECK (length(username) >= 3),
    CONSTRAINT chk_phone_format CHECK (phone ~ '^1[3-9]\d{9}$'),
    CONSTRAINT chk_id_card_format CHECK (id_card IS NULL OR length(id_card) = 18),
    CONSTRAINT chk_role_valid CHECK (role IN ('user', 'staff', 'admin'))
);

-- 注释
COMMENT ON TABLE users IS '用户表';
COMMENT ON COLUMN users.role IS '角色：user-普通用户, staff-员工, admin-管理员';
```

#### 包裹表（高级约束）
```sql
CREATE TABLE parcels (
    id BIGSERIAL PRIMARY KEY,
    tracking_number VARCHAR(50) NOT NULL UNIQUE,
    pickup_code VARCHAR(20) NOT NULL UNIQUE,
    recipient_name VARCHAR(100) NOT NULL,
    recipient_phone VARCHAR(20) NOT NULL,
    recipient_id_card VARCHAR(18),
    courier_company VARCHAR(50) NOT NULL,
    size VARCHAR(20) NOT NULL,
    weight DECIMAL(10, 2),
    status VARCHAR(20) NOT NULL DEFAULT 'received',
    shelf_id BIGINT REFERENCES shelves(id) ON DELETE SET NULL,
    received_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    shelved_at TIMESTAMPTZ,
    picked_up_at TIMESTAMPTZ,
    expected_overdue_at TIMESTAMPTZ,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,

    -- CHECK约束
    CONSTRAINT chk_size_valid CHECK (size IN ('small', 'medium', 'large')),
    CONSTRAINT chk_weight_positive CHECK (weight > 0),
    CONSTRAINT chk_status_valid CHECK (status IN (
        'received', 'shelved', 'ready_for_pickup',
        'picked_up', 'overdue', 'returned'
    )),
    CONSTRAINT chk_pickup_code_format CHECK (pickup_code ~ '^[A-Z][0-9A-Z]{5}$'),

    -- 时间逻辑约束
    CONSTRAINT chk_shelved_after_received CHECK (
        shelved_at IS NULL OR shelved_at >= received_at
    ),
    CONSTRAINT chk_picked_up_after_shelved CHECK (
        picked_up_at IS NULL OR
        (shelved_at IS NOT NULL AND picked_up_at >= shelved_at)
    ),

    -- EXCLUDE约束：防止同一货架同时有太多包裹（通过触发器实现）
    -- 状态一致性：picked_up状态必须有取件时间
    CONSTRAINT chk_status_timestamp_consistency CHECK (
        (status != 'picked_up' OR picked_up_at IS NOT NULL) AND
        (status != 'shelved' OR shelved_at IS NOT NULL)
    )
);

COMMENT ON TABLE parcels IS '包裹表';
```

#### 货架表（高级约束）
```sql
CREATE TABLE shelves (
    id BIGSERIAL PRIMARY KEY,
    shelf_code VARCHAR(50) NOT NULL UNIQUE,
    area VARCHAR(10) NOT NULL,
    floor INT NOT NULL,
    column INT NOT NULL,
    type VARCHAR(20) NOT NULL,
    capacity INT NOT NULL DEFAULT 10,
    current_count INT NOT NULL DEFAULT 0,
    status VARCHAR(20) NOT NULL DEFAULT 'available',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,

    -- CHECK约束
    CONSTRAINT chk_floor_positive CHECK (floor > 0),
    CONSTRAINT chk_column_positive CHECK (column > 0),
    CONSTRAINT chk_capacity_positive CHECK (capacity > 0),
    CONSTRAINT chk_current_count_valid CHECK (
        current_count >= 0 AND current_count <= capacity
    ),
    CONSTRAINT chk_type_valid CHECK (type IN ('small', 'medium', 'large')),
    CONSTRAINT chk_status_valid CHECK (status IN ('available', 'maintenance', 'disabled'))
);

-- 唯一性约束：同一位置只能有一个货架
CREATE UNIQUE INDEX idx_shelves_position
ON shelves(area, floor, column)
WHERE deleted_at IS NULL;

COMMENT ON TABLE shelves IS '货架表';
```

#### 快递价格配置表
```sql
CREATE TABLE courier_prices (
    id BIGSERIAL PRIMARY KEY,
    courier_company VARCHAR(50) NOT NULL UNIQUE,
    first_weight DECIMAL(10, 2) NOT NULL DEFAULT 1.0,
    first_price DECIMAL(10, 2) NOT NULL,
    additional_price DECIMAL(10, 2) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_first_weight_positive CHECK (first_weight > 0),
    CONSTRAINT chk_first_price_positive CHECK (first_price >= 0),
    CONSTRAINT chk_additional_price_positive CHECK (additional_price >= 0)
);

COMMENT ON TABLE courier_prices IS '快递价格配置表';
```

#### 寄件表
```sql
CREATE TABLE shipments (
    id BIGSERIAL PRIMARY KEY,
    shipment_number VARCHAR(50) NOT NULL UNIQUE,
    sender_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
    sender_name VARCHAR(100) NOT NULL,
    sender_phone VARCHAR(20) NOT NULL,
    recipient_name VARCHAR(100) NOT NULL,
    recipient_phone VARCHAR(20) NOT NULL,
    recipient_address TEXT NOT NULL,
    courier_company VARCHAR(50) NOT NULL,
    weight DECIMAL(10, 2) NOT NULL,
    volume DECIMAL(10, 4),
    freight DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    shipped_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,

    CONSTRAINT chk_weight_positive CHECK (weight > 0),
    CONSTRAINT chk_volume_positive CHECK (volume IS NULL OR volume > 0),
    CONSTRAINT chk_freight_non_negative CHECK (freight >= 0),
    CONSTRAINT chk_status_valid CHECK (status IN (
        'pending', 'shipped', 'in_transit', 'delivered'
    ))
);
```

#### 滞留记录表
```sql
CREATE TABLE overdue_records (
    id BIGSERIAL PRIMARY KEY,
    parcel_id BIGINT NOT NULL UNIQUE REFERENCES parcels(id) ON DELETE CASCADE,
    overdue_start_at TIMESTAMPTZ NOT NULL,
    reminder_count INT NOT NULL DEFAULT 0,
    last_reminder_at TIMESTAMPTZ,
    overdue_fee DECIMAL(10, 2) NOT NULL DEFAULT 0,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,

    CONSTRAINT chk_reminder_count_non_negative CHECK (reminder_count >= 0),
    CONSTRAINT chk_overdue_fee_non_negative CHECK (overdue_fee >= 0),
    CONSTRAINT chk_status_valid CHECK (status IN ('pending', 'reminded', 'returned'))
);
```

#### 操作日志表（分区表）
```sql
CREATE TABLE operation_logs (
    id BIGSERIAL,
    operator_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
    operation_type VARCHAR(50) NOT NULL,
    object_type VARCHAR(50) NOT NULL,
    object_id BIGINT NOT NULL,
    description TEXT,
    ip_address INET,  -- 使用PostgreSQL原生IP类型
    operated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (id, operated_at)  -- 分区键包含在主键中
) PARTITION BY RANGE (operated_at);

-- 创建分区（按月）
CREATE TABLE operation_logs_2025_01 PARTITION OF operation_logs
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE operation_logs_2025_02 PARTITION OF operation_logs
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- 注：实际使用时可通过脚本自动创建未来月份的分区

COMMENT ON TABLE operation_logs IS '操作日志表（按月分区）';
```

---

## 4. PostgreSQL高级特性应用

### 4.1 触发器（Triggers）

#### 触发器1：自动更新updated_at时间戳
```sql
-- 创建通用的更新时间戳函数
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 为各表创建触发器
CREATE TRIGGER trg_users_update_timestamp
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_parcels_update_timestamp
    BEFORE UPDATE ON parcels
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_shelves_update_timestamp
    BEFORE UPDATE ON shelves
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### 触发器2：货架占用数自动维护（核心业务逻辑）
```sql
-- 包裹上架/取件时自动更新货架占用数
CREATE OR REPLACE FUNCTION maintain_shelf_count()
RETURNS TRIGGER AS $$
DECLARE
    v_old_shelf_id BIGINT;
    v_new_shelf_id BIGINT;
BEGIN
    -- INSERT操作
    IF (TG_OP = 'INSERT') THEN
        IF NEW.shelf_id IS NOT NULL AND NEW.status IN ('shelved', 'ready_for_pickup') THEN
            UPDATE shelves
            SET current_count = current_count + 1
            WHERE id = NEW.shelf_id AND deleted_at IS NULL;
        END IF;
        RETURN NEW;
    END IF;

    -- UPDATE操作
    IF (TG_OP = 'UPDATE') THEN
        v_old_shelf_id := OLD.shelf_id;
        v_new_shelf_id := NEW.shelf_id;

        -- 包裹从旧货架移除
        IF v_old_shelf_id IS NOT NULL AND OLD.status IN ('shelved', 'ready_for_pickup') THEN
            IF NEW.status IN ('picked_up', 'returned') OR v_new_shelf_id != v_old_shelf_id THEN
                UPDATE shelves
                SET current_count = current_count - 1
                WHERE id = v_old_shelf_id AND deleted_at IS NULL;
            END IF;
        END IF;

        -- 包裹添加到新货架
        IF v_new_shelf_id IS NOT NULL AND NEW.status IN ('shelved', 'ready_for_pickup') THEN
            IF OLD.status NOT IN ('shelved', 'ready_for_pickup') OR v_new_shelf_id != v_old_shelf_id THEN
                UPDATE shelves
                SET current_count = current_count + 1
                WHERE id = v_new_shelf_id AND deleted_at IS NULL;
            END IF;
        END IF;

        RETURN NEW;
    END IF;

    -- DELETE操作
    IF (TG_OP = 'DELETE') THEN
        IF OLD.shelf_id IS NOT NULL AND OLD.status IN ('shelved', 'ready_for_pickup') THEN
            UPDATE shelves
            SET current_count = current_count - 1
            WHERE id = OLD.shelf_id AND deleted_at IS NULL;
        END IF;
        RETURN OLD;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_maintain_shelf_count
    AFTER INSERT OR UPDATE OR DELETE ON parcels
    FOR EACH ROW
    EXECUTE FUNCTION maintain_shelf_count();
```

#### 触发器3：包裹状态变更自动记录日志
```sql
CREATE OR REPLACE FUNCTION log_parcel_status_change()
RETURNS TRIGGER AS $$
BEGIN
    -- 只在状态改变时记录
    IF (TG_OP = 'UPDATE' AND OLD.status != NEW.status) THEN
        INSERT INTO operation_logs (
            operator_id,
            operation_type,
            object_type,
            object_id,
            description,
            operated_at
        ) VALUES (
            NULLIF(current_setting('app.current_user_id', true), '')::BIGINT,
            'parcel_status_changed',
            'parcel',
            NEW.id,
            format('包裹状态从 %s 变更为 %s', OLD.status, NEW.status),
            CURRENT_TIMESTAMP
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_log_parcel_status_change
    AFTER UPDATE ON parcels
    FOR EACH ROW
    EXECUTE FUNCTION log_parcel_status_change();

-- 应用层设置当前用户ID（GORM中使用）:
-- SET app.current_user_id = '123';
```

#### 触发器4：自动计算预计滞留时间
```sql
CREATE OR REPLACE FUNCTION set_expected_overdue_time()
RETURNS TRIGGER AS $$
BEGIN
    -- 包裹入库时自动设置预计滞留时间（3天后）
    IF (TG_OP = 'INSERT') THEN
        NEW.expected_overdue_at := NEW.received_at + INTERVAL '3 days';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_expected_overdue_time
    BEFORE INSERT ON parcels
    FOR EACH ROW
    EXECUTE FUNCTION set_expected_overdue_time();
```

#### 触发器5：货架容量限制检查
```sql
CREATE OR REPLACE FUNCTION check_shelf_capacity()
RETURNS TRIGGER AS $$
DECLARE
    v_capacity INT;
    v_current_count INT;
BEGIN
    IF NEW.shelf_id IS NOT NULL THEN
        SELECT capacity, current_count INTO v_capacity, v_current_count
        FROM shelves
        WHERE id = NEW.shelf_id AND deleted_at IS NULL;

        IF NOT FOUND THEN
            RAISE EXCEPTION '货架不存在或已删除';
        END IF;

        IF v_current_count >= v_capacity THEN
            RAISE EXCEPTION '货架已满，无法分配';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_shelf_capacity
    BEFORE INSERT OR UPDATE OF shelf_id ON parcels
    FOR EACH ROW
    WHEN (NEW.shelf_id IS NOT NULL)
    EXECUTE FUNCTION check_shelf_capacity();
```

### 4.2 存储过程和函数（Stored Procedures & Functions）

#### 函数1：运费计算函数
```sql
CREATE OR REPLACE FUNCTION calculate_freight(
    p_courier_company VARCHAR,
    p_weight DECIMAL,
    p_volume DECIMAL DEFAULT NULL,
    p_declared_value DECIMAL DEFAULT 0,
    p_require_receipt BOOLEAN DEFAULT false
)
RETURNS TABLE(
    total_freight DECIMAL,
    base_freight DECIMAL,
    insurance_fee DECIMAL,
    receipt_fee DECIMAL,
    chargeable_weight DECIMAL
) AS $$
DECLARE
    v_first_weight DECIMAL;
    v_first_price DECIMAL;
    v_additional_price DECIMAL;
    v_volume_weight DECIMAL;
    v_chargeable_weight DECIMAL;
    v_base_freight DECIMAL;
    v_insurance_fee DECIMAL := 0;
    v_receipt_fee DECIMAL := 0;
    v_additional_weight DECIMAL;
BEGIN
    -- 获取快递价格配置
    SELECT cp.first_weight, cp.first_price, cp.additional_price
    INTO v_first_weight, v_first_price, v_additional_price
    FROM courier_prices cp
    WHERE cp.courier_company = p_courier_company AND cp.is_active = true;

    IF NOT FOUND THEN
        RAISE EXCEPTION '快递公司 % 不存在或未激活', p_courier_company;
    END IF;

    -- 计算体积重量（m³转换为kg）
    IF p_volume IS NOT NULL THEN
        v_volume_weight := (p_volume * 1000000) / 6000 / 1000;
    ELSE
        v_volume_weight := 0;
    END IF;

    -- 确定计费重量
    v_chargeable_weight := GREATEST(p_weight, v_volume_weight);

    -- 计算基础运费
    IF v_chargeable_weight <= v_first_weight THEN
        v_base_freight := v_first_price;
    ELSE
        v_additional_weight := CEIL(v_chargeable_weight - v_first_weight);
        v_base_freight := v_first_price + (v_additional_weight * v_additional_price);
    END IF;

    -- 计算保价费（声明价值的0.5%，最低2元）
    IF p_declared_value > 0 THEN
        v_insurance_fee := GREATEST(p_declared_value * 0.005, 2.0);
    END IF;

    -- 签收回单费
    IF p_require_receipt THEN
        v_receipt_fee := 5.0;
    END IF;

    -- 返回结果
    RETURN QUERY SELECT
        v_base_freight + v_insurance_fee + v_receipt_fee,
        v_base_freight,
        v_insurance_fee,
        v_receipt_fee,
        v_chargeable_weight;
END;
$$ LANGUAGE plpgsql;

-- 使用示例：
-- SELECT * FROM calculate_freight('顺丰速运', 2.5, 0.01, 100, true);
```

#### 函数2：货架分配函数（智能算法）
```sql
CREATE OR REPLACE FUNCTION allocate_shelf(p_parcel_size VARCHAR)
RETURNS BIGINT AS $$
DECLARE
    v_shelf_id BIGINT;
    v_candidate_types VARCHAR[];
BEGIN
    -- 确定候选货架类型
    CASE p_parcel_size
        WHEN 'small' THEN v_candidate_types := ARRAY['small', 'medium', 'large'];
        WHEN 'medium' THEN v_candidate_types := ARRAY['medium', 'large'];
        WHEN 'large' THEN v_candidate_types := ARRAY['large'];
        ELSE RAISE EXCEPTION '无效的包裹大小: %', p_parcel_size;
    END CASE;

    -- 按优先级选择货架（优先级 = 空间因子*0.5 + 位置因子*0.3 + 负载因子*0.2）
    SELECT id INTO v_shelf_id
    FROM shelves
    WHERE
        type = ANY(v_candidate_types)
        AND status = 'available'
        AND current_count < capacity
        AND deleted_at IS NULL
    ORDER BY
        -- 空间因子
        ((capacity - current_count)::NUMERIC / capacity) * 0.5 +
        -- 位置因子（楼层和列号越小越好）
        (1.0 / (floor + column)) * 0.3 +
        -- 负载因子
        (1.0 - (current_count::NUMERIC / capacity)) * 0.2
    DESC
    LIMIT 1;

    IF v_shelf_id IS NULL THEN
        RAISE EXCEPTION '没有可用货架，类型: %', p_parcel_size;
    END IF;

    RETURN v_shelf_id;
END;
$$ LANGUAGE plpgsql;

-- 使用示例：
-- SELECT allocate_shelf('small');
```

#### 函数3：包裹入库存储过程（完整业务流程）
```sql
CREATE OR REPLACE FUNCTION receive_parcel(
    p_tracking_number VARCHAR,
    p_recipient_name VARCHAR,
    p_recipient_phone VARCHAR,
    p_recipient_id_card VARCHAR,
    p_courier_company VARCHAR,
    p_size VARCHAR,
    p_weight DECIMAL,
    p_notes TEXT DEFAULT NULL
)
RETURNS TABLE(
    parcel_id BIGINT,
    pickup_code VARCHAR,
    shelf_id BIGINT,
    shelf_code VARCHAR
) AS $$
DECLARE
    v_parcel_id BIGINT;
    v_pickup_code VARCHAR;
    v_shelf_id BIGINT;
    v_shelf_code VARCHAR;
    v_area VARCHAR;
BEGIN
    -- 1. 检查快递单号是否已存在
    IF EXISTS (SELECT 1 FROM parcels WHERE tracking_number = p_tracking_number AND deleted_at IS NULL) THEN
        RAISE EXCEPTION '快递单号已存在: %', p_tracking_number;
    END IF;

    -- 2. 分配货架
    v_shelf_id := allocate_shelf(p_size);

    -- 获取货架信息（用于生成取件码）
    SELECT s.shelf_code, s.area INTO v_shelf_code, v_area
    FROM shelves s
    WHERE s.id = v_shelf_id;

    -- 3. 生成取件码（格式：区域字母 + 5位随机字符）
    v_pickup_code := generate_pickup_code(v_area);

    -- 4. 插入包裹记录
    INSERT INTO parcels (
        tracking_number,
        pickup_code,
        recipient_name,
        recipient_phone,
        recipient_id_card,
        courier_company,
        size,
        weight,
        status,
        shelf_id,
        received_at,
        notes
    ) VALUES (
        p_tracking_number,
        v_pickup_code,
        p_recipient_name,
        p_recipient_phone,
        p_recipient_id_card,
        p_courier_company,
        p_size,
        p_weight,
        'received',
        v_shelf_id,
        CURRENT_TIMESTAMP,
        p_notes
    ) RETURNING id INTO v_parcel_id;

    -- 5. 返回结果
    RETURN QUERY SELECT v_parcel_id, v_pickup_code, v_shelf_id, v_shelf_code;
END;
$$ LANGUAGE plpgsql;

-- 辅助函数：生成取件码
CREATE OR REPLACE FUNCTION generate_pickup_code(p_area VARCHAR)
RETURNS VARCHAR AS $$
DECLARE
    v_code VARCHAR;
    v_exists BOOLEAN;
    v_attempt INT := 0;
    v_chars VARCHAR := '0123456789ABCDEFGHJKMNPQRSTUVWXYZ';  -- 去除易混淆字符
BEGIN
    LOOP
        -- 生成随机取件码
        v_code := UPPER(COALESCE(SUBSTRING(p_area, 1, 1), 'A')) ||
                  SUBSTRING(v_chars FROM (random() * 32)::INT + 1 FOR 1) ||
                  SUBSTRING(v_chars FROM (random() * 32)::INT + 1 FOR 1) ||
                  SUBSTRING(v_chars FROM (random() * 32)::INT + 1 FOR 1) ||
                  SUBSTRING(v_chars FROM (random() * 32)::INT + 1 FOR 1) ||
                  SUBSTRING(v_chars FROM (random() * 32)::INT + 1 FOR 1);

        -- 检查是否已存在
        SELECT EXISTS(SELECT 1 FROM parcels WHERE pickup_code = v_code) INTO v_exists;

        IF NOT v_exists THEN
            RETURN v_code;
        END IF;

        v_attempt := v_attempt + 1;
        IF v_attempt > 10 THEN
            RAISE EXCEPTION '生成取件码失败，请重试';
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 使用示例：
-- SELECT * FROM receive_parcel(
--     'SF1234567890',
--     '张三',
--     '13800138000',
--     '440101199001011234',
--     '顺丰速运',
--     'small',
--     1.5,
--     '易碎品'
-- );
```

#### 函数4：包裹取件存储过程（事务控制）
```sql
CREATE OR REPLACE FUNCTION pickup_parcel(
    p_pickup_code VARCHAR,
    p_recipient_phone VARCHAR
)
RETURNS TABLE(
    success BOOLEAN,
    message TEXT,
    parcel_id BIGINT,
    tracking_number VARCHAR
) AS $$
DECLARE
    v_parcel_id BIGINT;
    v_tracking_number VARCHAR;
    v_status VARCHAR;
    v_phone VARCHAR;
    v_shelf_id BIGINT;
BEGIN
    -- 1. 查询包裹（使用行级锁）
    SELECT p.id, p.tracking_number, p.status, p.recipient_phone, p.shelf_id
    INTO v_parcel_id, v_tracking_number, v_status, v_phone, v_shelf_id
    FROM parcels p
    WHERE p.pickup_code = p_pickup_code AND p.deleted_at IS NULL
    FOR UPDATE;  -- 行级锁，防止并发冲突

    -- 2. 验证包裹是否存在
    IF v_parcel_id IS NULL THEN
        RETURN QUERY SELECT false, '取件码不存在'::TEXT, NULL::BIGINT, NULL::VARCHAR;
        RETURN;
    END IF;

    -- 3. 验证手机号
    IF v_phone != p_recipient_phone THEN
        RETURN QUERY SELECT false, '手机号不匹配'::TEXT, NULL::BIGINT, NULL::VARCHAR;
        RETURN;
    END IF;

    -- 4. 验证状态
    IF v_status NOT IN ('ready_for_pickup', 'overdue', 'shelved') THEN
        RETURN QUERY SELECT
            false,
            format('包裹状态不允许取件，当前状态：%s', v_status)::TEXT,
            NULL::BIGINT,
            NULL::VARCHAR;
        RETURN;
    END IF;

    -- 5. 更新包裹状态
    UPDATE parcels
    SET
        status = 'picked_up',
        picked_up_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = v_parcel_id;

    -- 6. 如果有滞留记录，更新状态
    UPDATE overdue_records
    SET
        status = 'picked_up',
        updated_at = CURRENT_TIMESTAMP
    WHERE parcel_id = v_parcel_id;

    -- 7. 返回成功结果
    RETURN QUERY SELECT true, '取件成功'::TEXT, v_parcel_id, v_tracking_number;
END;
$$ LANGUAGE plpgsql;

-- 使用示例：
-- SELECT * FROM pickup_parcel('A12B45', '13800138000');
```

#### 函数5：滞留费用计算函数
```sql
CREATE OR REPLACE FUNCTION calculate_overdue_fee(p_overdue_start_at TIMESTAMPTZ)
RETURNS DECIMAL AS $$
DECLARE
    v_overdue_days INT;
    v_free_days INT := 3;  -- 免费保管3天
    v_fee_per_day DECIMAL := 1.0;  -- 每天1元
    v_fee DECIMAL;
BEGIN
    -- 计算滞留天数
    v_overdue_days := EXTRACT(DAY FROM (CURRENT_TIMESTAMP - p_overdue_start_at));

    -- 计算费用（超过免费期的部分）
    IF v_overdue_days <= v_free_days THEN
        v_fee := 0;
    ELSE
        v_fee := (v_overdue_days - v_free_days) * v_fee_per_day;
    END IF;

    RETURN v_fee;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 视图（Views）

#### 视图1：包裹统计视图
```sql
CREATE OR REPLACE VIEW v_parcel_statistics AS
SELECT
    DATE(received_at) as stat_date,
    status,
    courier_company,
    size,
    COUNT(*) as parcel_count,
    AVG(weight) as avg_weight,
    AVG(
        CASE
            WHEN picked_up_at IS NOT NULL THEN
                EXTRACT(EPOCH FROM (picked_up_at - received_at)) / 3600
            ELSE NULL
        END
    ) as avg_pickup_hours
FROM parcels
WHERE deleted_at IS NULL
GROUP BY DATE(received_at), status, courier_company, size;

COMMENT ON VIEW v_parcel_statistics IS '包裹统计视图：按日期、状态、快递公司、大小聚合';
```

#### 视图2：货架利用率视图
```sql
CREATE OR REPLACE VIEW v_shelf_utilization AS
SELECT
    s.id,
    s.shelf_code,
    s.area,
    s.floor,
    s.column,
    s.type,
    s.capacity,
    s.current_count,
    ROUND((s.current_count::NUMERIC / s.capacity) * 100, 2) as utilization_rate,
    s.status,
    CASE
        WHEN s.current_count = 0 THEN 'empty'
        WHEN s.current_count < s.capacity * 0.5 THEN 'low'
        WHEN s.current_count < s.capacity * 0.8 THEN 'medium'
        WHEN s.current_count < s.capacity THEN 'high'
        ELSE 'full'
    END as load_level
FROM shelves s
WHERE s.deleted_at IS NULL;

COMMENT ON VIEW v_shelf_utilization IS '货架利用率视图：实时展示货架使用情况';
```

#### 视图3：用户包裹视图（数据安全）
```sql
CREATE OR REPLACE VIEW v_user_parcels AS
SELECT
    p.id,
    p.tracking_number,
    p.pickup_code,
    p.recipient_name,
    p.recipient_phone,
    -- 脱敏：身份证号只显示前6位和后4位
    CASE
        WHEN p.recipient_id_card IS NOT NULL THEN
            SUBSTRING(p.recipient_id_card, 1, 6) || '********' ||
            SUBSTRING(p.recipient_id_card, 15, 4)
        ELSE NULL
    END as recipient_id_card_masked,
    p.courier_company,
    p.size,
    p.status,
    s.shelf_code,
    s.area,
    s.floor,
    s.column,
    p.received_at,
    p.expected_overdue_at,
    -- 计算剩余时间
    CASE
        WHEN p.status IN ('ready_for_pickup', 'shelved', 'overdue') THEN
            EXTRACT(EPOCH FROM (p.expected_overdue_at - CURRENT_TIMESTAMP)) / 3600
        ELSE NULL
    END as remaining_hours
FROM parcels p
LEFT JOIN shelves s ON p.shelf_id = s.id
WHERE p.deleted_at IS NULL;

COMMENT ON VIEW v_user_parcels IS '用户包裹视图：包含脱敏信息和剩余时间';
```

#### 视图4：待处理滞留件视图
```sql
CREATE OR REPLACE VIEW v_pending_overdue_parcels AS
SELECT
    p.id as parcel_id,
    p.tracking_number,
    p.pickup_code,
    p.recipient_name,
    p.recipient_phone,
    p.courier_company,
    s.shelf_code,
    p.received_at,
    p.expected_overdue_at,
    EXTRACT(DAY FROM (CURRENT_TIMESTAMP - p.expected_overdue_at)) as overdue_days,
    or_rec.reminder_count,
    or_rec.last_reminder_at,
    calculate_overdue_fee(or_rec.overdue_start_at) as current_overdue_fee
FROM parcels p
LEFT JOIN shelves s ON p.shelf_id = s.id
LEFT JOIN overdue_records or_rec ON p.id = or_rec.parcel_id
WHERE
    p.status = 'overdue'
    AND p.deleted_at IS NULL
    AND or_rec.status != 'returned'
ORDER BY overdue_days DESC;

COMMENT ON VIEW v_pending_overdue_parcels IS '待处理滞留件视图：包含滞留天数和费用';
```

#### 视图5：每日运营仪表盘视图
```sql
CREATE OR REPLACE VIEW v_daily_dashboard AS
SELECT
    CURRENT_DATE as stat_date,
    -- 今日入库
    (SELECT COUNT(*) FROM parcels WHERE DATE(received_at) = CURRENT_DATE AND deleted_at IS NULL)
        as today_received,
    -- 今日取件
    (SELECT COUNT(*) FROM parcels WHERE DATE(picked_up_at) = CURRENT_DATE AND deleted_at IS NULL)
        as today_picked_up,
    -- 今日滞留
    (SELECT COUNT(*) FROM overdue_records WHERE DATE(overdue_start_at) = CURRENT_DATE AND deleted_at IS NULL)
        as today_overdue,
    -- 待取件总数
    (SELECT COUNT(*) FROM parcels WHERE status = 'ready_for_pickup' AND deleted_at IS NULL)
        as total_pending_pickup,
    -- 滞留件总数
    (SELECT COUNT(*) FROM parcels WHERE status = 'overdue' AND deleted_at IS NULL)
        as total_overdue,
    -- 货架总容量
    (SELECT COALESCE(SUM(capacity), 0) FROM shelves WHERE status = 'available' AND deleted_at IS NULL)
        as total_capacity,
    -- 货架已用
    (SELECT COALESCE(SUM(current_count), 0) FROM shelves WHERE status = 'available' AND deleted_at IS NULL)
        as total_used,
    -- 货架利用率
    ROUND(
        (SELECT COALESCE(SUM(current_count), 0)::NUMERIC FROM shelves WHERE status = 'available' AND deleted_at IS NULL) /
        NULLIF((SELECT COALESCE(SUM(capacity), 0)::NUMERIC FROM shelves WHERE status = 'available' AND deleted_at IS NULL), 0)
        * 100, 2
    ) as utilization_rate;

COMMENT ON VIEW v_daily_dashboard IS '每日运营仪表盘视图：关键业务指标汇总';
```

### 4.4 高级索引策略

#### 4.4.1 部分索引（Partial Index）
```sql
-- 只索引未删除的数据
CREATE INDEX idx_parcels_pickup_code_active ON parcels(pickup_code)
WHERE deleted_at IS NULL;

CREATE INDEX idx_parcels_tracking_active ON parcels(tracking_number)
WHERE deleted_at IS NULL;

-- 只索引特定状态的包裹
CREATE INDEX idx_parcels_pending_pickup ON parcels(received_at DESC)
WHERE status IN ('ready_for_pickup', 'shelved') AND deleted_at IS NULL;

CREATE INDEX idx_parcels_overdue_active ON parcels(expected_overdue_at)
WHERE status IN ('ready_for_pickup', 'shelved') AND deleted_at IS NULL;
```

#### 4.4.2 复合索引
```sql
-- 状态+时间复合索引（支持按状态和时间排序查询）
CREATE INDEX idx_parcels_status_received ON parcels(status, received_at DESC)
WHERE deleted_at IS NULL;

-- 货架分配算法优化索引
CREATE INDEX idx_shelves_allocation ON shelves(type, status, current_count, capacity)
WHERE deleted_at IS NULL AND status = 'available';

-- 用户查询优化
CREATE INDEX idx_parcels_phone_status ON parcels(recipient_phone, status, received_at DESC)
WHERE deleted_at IS NULL;
```

#### 4.4.3 表达式索引
```sql
-- 支持不区分大小写的用户名查询
CREATE INDEX idx_users_username_lower ON users(LOWER(username))
WHERE deleted_at IS NULL;

-- 支持日期范围查询
CREATE INDEX idx_parcels_received_date ON parcels(DATE(received_at))
WHERE deleted_at IS NULL;

-- 货架利用率索引
CREATE INDEX idx_shelves_utilization ON shelves(
    ROUND((current_count::NUMERIC / capacity) * 100, 2)
)
WHERE deleted_at IS NULL AND status = 'available';
```

#### 4.4.4 GIN索引（全文搜索）
```sql
-- 为包裹备注启用全文搜索
ALTER TABLE parcels ADD COLUMN notes_tsv tsvector;

-- 创建触发器自动更新tsvector
CREATE OR REPLACE FUNCTION parcels_notes_tsv_update()
RETURNS TRIGGER AS $$
BEGIN
    NEW.notes_tsv := to_tsvector('chinese', COALESCE(NEW.notes, ''));
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_parcels_notes_tsv
    BEFORE INSERT OR UPDATE OF notes ON parcels
    FOR EACH ROW
    EXECUTE FUNCTION parcels_notes_tsv_update();

-- 创建GIN索引
CREATE INDEX idx_parcels_notes_gin ON parcels USING GIN(notes_tsv);

-- 使用示例：
-- SELECT * FROM parcels WHERE notes_tsv @@ to_tsquery('chinese', '易碎');
```

#### 4.4.5 BRIN索引（时间序列数据）
```sql
-- 对操作日志的时间字段使用BRIN索引（节省空间）
CREATE INDEX idx_operation_logs_operated_at_brin ON operation_logs
USING BRIN(operated_at)
WITH (pages_per_range = 128);

-- BRIN索引特别适合时间序列数据，占用空间小，对按时间范围查询很高效
```

### 4.5 事务控制和并发处理

#### 4.5.1 事务隔离级别
```sql
-- 设置事务隔离级别（应用层可配置）
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- 执行业务逻辑
COMMIT;

-- GORM中设置隔离级别示例：
-- db.Transaction(func(tx *gorm.DB) error {
--     tx.Exec("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE")
--     // 业务逻辑
--     return nil
-- })
```

#### 4.5.2 使用保存点（Savepoint）
```sql
-- 复杂事务中使用保存点
BEGIN;
    -- 步骤1：包裹入库
    INSERT INTO parcels (...) VALUES (...);
    SAVEPOINT sp1;

    -- 步骤2：更新货架（可能失败）
    UPDATE shelves SET current_count = current_count + 1 WHERE id = 1;

    -- 如果失败，回滚到保存点
    -- ROLLBACK TO SAVEPOINT sp1;

    -- 步骤3：记录日志
    INSERT INTO operation_logs (...) VALUES (...);
COMMIT;
```

#### 4.5.3 行级锁（FOR UPDATE）
```sql
-- 悲观锁：防止并发取件
SELECT * FROM parcels
WHERE pickup_code = 'A12B45' AND deleted_at IS NULL
FOR UPDATE;  -- 行级排他锁

-- 乐观锁：使用版本号
ALTER TABLE parcels ADD COLUMN version INT DEFAULT 0;

UPDATE parcels
SET status = 'picked_up', version = version + 1
WHERE id = 123 AND version = 5;  -- 只有版本号匹配才更新
```

#### 4.5.4 咨询锁（Advisory Lock）
```sql
-- 获取应用级锁（防止重复的定时任务执行）
SELECT pg_try_advisory_lock(123456);  -- 尝试获取锁

-- 业务逻辑...

SELECT pg_advisory_unlock(123456);  -- 释放锁
```

### 4.6 性能优化配置

#### 4.6.1 VACUUM和ANALYZE
```sql
-- 定期清理和分析表
VACUUM ANALYZE parcels;
VACUUM ANALYZE shelves;

-- 自动VACUUM配置（postgresql.conf）
-- autovacuum = on
-- autovacuum_vacuum_scale_factor = 0.1
```

#### 4.6.2 物化视图刷新策略
```sql
-- 创建物化视图
CREATE MATERIALIZED VIEW mv_monthly_statistics AS
SELECT
    DATE_TRUNC('month', received_at) as month,
    COUNT(*) as total_parcels,
    COUNT(*) FILTER (WHERE status = 'picked_up') as picked_up_count,
    AVG(EXTRACT(EPOCH FROM (picked_up_at - received_at)) / 3600) as avg_pickup_hours
FROM parcels
WHERE deleted_at IS NULL
GROUP BY DATE_TRUNC('month', received_at);

-- 创建索引
CREATE INDEX idx_mv_monthly_statistics_month ON mv_monthly_statistics(month);

-- 并发刷新（不锁表）
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_monthly_statistics;
```

#### 4.6.3 查询性能分析
```sql
-- 使用EXPLAIN ANALYZE分析查询
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM parcels
WHERE status = 'ready_for_pickup'
AND deleted_at IS NULL
ORDER BY received_at DESC
LIMIT 20;
```

---

## 5. GORM集成方案

虽然数据库层面实现了大量高级特性，但应用层使用GORM简化开发：

### 5.1 模型定义
```go
type Parcel struct {
    ID                 int64      `gorm:"primaryKey"`
    TrackingNumber     string     `gorm:"uniqueIndex:idx_tracking_active;not null"`
    PickupCode         string     `gorm:"uniqueIndex:idx_pickup_active;not null"`
    RecipientName      string     `gorm:"not null"`
    RecipientPhone     string     `gorm:"index:idx_phone_status"`
    Status             string     `gorm:"index:idx_status_received;not null;default:received"`
    ShelfID            *int64     `gorm:"index"`
    ReceivedAt         time.Time  `gorm:"not null;default:CURRENT_TIMESTAMP"`
    ExpectedOverdueAt  *time.Time
    CreatedAt          time.Time
    UpdatedAt          time.Time
    DeletedAt          gorm.DeletedAt `gorm:"index"`

    // 关联
    Shelf              *Shelf     `gorm:"foreignKey:ShelfID"`
}
```

### 5.2 调用存储过程
```go
// 调用包裹入库存储过程
type ReceiveParcelResult struct {
    ParcelID   int64  `gorm:"column:parcel_id"`
    PickupCode string `gorm:"column:pickup_code"`
    ShelfID    int64  `gorm:"column:shelf_id"`
    ShelfCode  string `gorm:"column:shelf_code"`
}

func (r *ParcelRepository) ReceiveParcel(ctx context.Context, params *ReceiveParcelParams) (*ReceiveParcelResult, error) {
    var result ReceiveParcelResult

    err := r.db.WithContext(ctx).
        Raw(`SELECT * FROM receive_parcel(?, ?, ?, ?, ?, ?, ?, ?)`,
            params.TrackingNumber,
            params.RecipientName,
            params.RecipientPhone,
            params.RecipientIDCard,
            params.CourierCompany,
            params.Size,
            params.Weight,
            params.Notes,
        ).
        Scan(&result).Error

    return &result, err
}
```

### 5.3 使用视图
```go
// 查询用户包裹（使用视图）
func (r *ParcelRepository) GetUserParcels(ctx context.Context, phone string) ([]UserParcel, error) {
    var parcels []UserParcel

    err := r.db.WithContext(ctx).
        Table("v_user_parcels").
        Where("recipient_phone = ?", phone).
        Order("received_at DESC").
        Find(&parcels).Error

    return parcels, err
}
```

### 5.4 设置当前用户（触发器需要）
```go
func (r *Repository) SetCurrentUser(ctx context.Context, userID int64) error {
    return r.db.WithContext(ctx).
        Exec("SET app.current_user_id = ?", userID).Error
}
```

---

## 6. 数据库脚本组织

### 6.1 脚本文件结构
```
backend/sql/
├── 01_init.sql              # 数据库初始化
├── 02_tables.sql            # 表结构创建
├── 03_indexes.sql           # 索引创建
├── 04_triggers.sql          # 触发器定义
├── 05_functions.sql         # 函数和存储过程
├── 06_views.sql             # 视图定义
├── 07_seed.sql              # 测试数据
└── 99_cleanup.sql           # 清理脚本
```

### 6.2 初始化数据
```sql
-- 初始化快递价格配置
INSERT INTO courier_prices (courier_company, first_price, additional_price) VALUES
    ('顺丰速运', 15.00, 5.00),
    ('中通快递', 10.00, 3.00),
    ('圆通快递', 10.00, 3.00),
    ('韵达快递', 10.00, 3.00),
    ('申通快递', 10.00, 3.00),
    ('邮政EMS', 12.00, 4.00);

-- 初始化货架数据
INSERT INTO shelves (shelf_code, area, floor, column, type, capacity) VALUES
    ('A-01-01', 'A', 1, 1, 'small', 20),
    ('A-01-02', 'A', 1, 2, 'small', 20),
    ('A-02-01', 'A', 2, 1, 'medium', 15),
    ('A-02-02', 'A', 2, 2, 'medium', 15),
    ('B-01-01', 'B', 1, 1, 'large', 10),
    ('B-01-02', 'B', 1, 2, 'large', 10);

-- 创建管理员账户
INSERT INTO users (username, password, real_name, phone, role) VALUES
    ('admin', '$2a$10$...', '系统管理员', '13800138000', 'admin');
```

---

## 7. 总结

本数据库设计充分体现了PostgreSQL的高级特性：

### 7.1 高级特性应用统计
| 特性类型 | 数量 | 应用场景 |
|---------|------|----------|
| 触发器 | 5个 | 自动维护货架计数、状态日志、时间计算、容量检查 |
| 存储过程/函数 | 6个 | 运费计算、货架分配、包裹入库/取件、取件码生成 |
| 视图 | 5个 | 统计分析、数据脱敏、业务查询简化 |
| 高级索引 | 15+ | 部分索引、复合索引、表达式索引、GIN、BRIN |
| CHECK约束 | 20+ | 数据完整性保证 |
| 分区表 | 1个 | 日志表按月分区 |

### 7.2 性能优化措施
✅ 多维度索引策略（单列、复合、部分、表达式）
✅ 分区表优化历史数据查询
✅ 物化视图缓存复杂聚合
✅ 触发器自动维护冗余字段
✅ 行级锁和事务隔离保证并发安全

### 7.3 业务逻辑下沉
✅ 核心业务逻辑通过存储过程实现（货架分配、包裹入库）
✅ 复杂计算通过函数封装（运费计算、滞留费用）
✅ 数据一致性通过触发器保证（货架计数、状态流转）
✅ 数据安全通过视图实现（脱敏、权限控制）

### 7.4 GORM与PostgreSQL的协同
- 应用层：GORM简化CRUD操作，提供对象关系映射
- 数据库层：PostgreSQL提供高级特性，保证性能和数据完整性
- 最佳实践：简单查询用GORM，复杂业务用存储过程

这种设计既保持了应用开发的便捷性，又充分发挥了PostgreSQL作为企业级数据库的强大功能。
