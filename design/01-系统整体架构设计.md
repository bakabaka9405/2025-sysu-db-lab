# 系统整体架构设计

## 1. 项目概述

### 1.1 项目名称
校园"最后一公里"物流驿站管理系统

### 1.2 项目背景
随着电商的快速发展，校园快递业务量激增。传统的快递收发管理方式效率低下，容易出现包裹丢失、查询困难等问题。本系统旨在通过信息化手段，实现包裹的高效管理，提升校园快递服务质量。

### 1.3 设计目标
- 支持高吞吐量的包裹收发业务
- 实现包裹全生命周期的状态追踪
- 优化查询性能，支持海量数据快速检索
- 提供智能化的包裹管理功能（OCR识别、自动分配货架等）
- 保证数据的一致性和完整性

### 1.4 技术选型

#### 后端技术栈
- **语言**: Go 1.21+
- **框架**: Gin (HTTP 服务器) + Nunu (项目脚手架)
- **ORM**: GORM
- **数据库**: PostgreSQL 17
- **依赖注入**: Google Wire
- **身份验证**: JWT (golang-jwt)
- **日志**: Uber Zap
- **API文档**: Swagger
- **测试**: Golang Mock, SQL Mock, httpexpect

#### 前端技术栈
- **框架**: Vue 3 + TypeScript
- **构建工具**: Farm
- **UI组件**: Naive UI
- **状态管理**: Pinia
- **HTTP客户端**: Axios
- **样式**: Scoped CSS

#### 基础设施
- **容器化**: Docker + Docker Compose
- **版本控制**: Git

## 2. 系统架构设计

### 2.1 总体架构

系统采用经典的三层架构模式：

```
┌─────────────────────────────────────────────────────────────┐
│                        前端展示层                             │
│              (Vue 3 + TypeScript + Naive UI)            │
└─────────────────────────────────────────────────────────────┘
                              ↕ HTTP/HTTPS
┌─────────────────────────────────────────────────────────────┐
│                        后端应用层                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   Handler   │  │  Middleware │  │   Router    │         │
│  │  (控制层)    │  │  (中间件)    │  │  (路由层)    │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│  ┌─────────────────────────────────────────────────┐       │
│  │              Service (业务逻辑层)                 │       │
│  │  - 包裹管理服务                                   │       │
│  │  - 货架管理服务                                   │       │
│  │  - 用户管理服务                                   │       │
│  │  - 运费计算服务                                   │       │
│  │  - 统计分析服务                                   │       │
│  └─────────────────────────────────────────────────┘       │
│  ┌─────────────────────────────────────────────────┐       │
│  │           Repository (数据访问层)                 │       │
│  │  - 包裹仓储                                       │       │
│  │  - 货架仓储                                       │       │
│  │  - 用户仓储                                       │       │
│  └─────────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────────┘
                              ↕ SQL
┌─────────────────────────────────────────────────────────────┐
│                        数据持久层                             │
│                   PostgreSQL Database                        │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│  │  包裹表  │ │  货架表  │ │  用户表  │ │  日志表  │      │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 分层架构详解

#### 2.2.1 Handler层（HTTP处理层）
- 负责接收和解析HTTP请求
- 参数验证和数据绑定
- 调用Service层处理业务逻辑
- 格式化响应数据
- 统一错误处理

#### 2.2.2 Service层（业务逻辑层）
- 实现核心业务逻辑
- 协调多个Repository进行数据操作
- 事务管理
- 业务规则验证
- 复杂计算逻辑（如运费计算、货架分配算法）

#### 2.2.3 Repository层（数据访问层）
- 封装数据库操作
- 提供统一的数据访问接口
- 支持事务操作
- 查询优化和缓存策略

#### 2.2.4 Model层（数据模型层）
- 定义领域实体
- 数据库表结构映射
- 业务对象定义

### 2.3 核心设计模式

#### 2.3.1 依赖注入（Dependency Injection）
使用Google Wire进行编译时依赖注入，提高代码的可测试性和可维护性。

```
Wire Provider Sets:
- repositorySet: 数据库连接 + 所有Repository实现
- serviceSet: 所有Service实现（依赖Repository）
- handlerSet: 所有Handler实现（依赖Service）
- serverSet: HTTP服务器配置
```

#### 2.3.2 仓储模式（Repository Pattern）
通过接口抽象数据访问逻辑，使业务逻辑与数据存储解耦。

#### 2.3.3 事务管理模式
Service层通过Transaction Manager统一管理数据库事务，保证数据一致性。

## 3. 核心功能模块

### 3.1 用户管理模块
- 用户注册/登录
- 身份认证（JWT）
- 角色权限管理（用户、管理员、驿站员工）
- 用户信息管理

### 3.2 包裹入库模块
- 包裹信息录入（支持OCR识别）
- 取件码自动生成
- 货架自动分配算法
- 包裹状态初始化
- 入库日志记录

### 3.3 包裹取件模块
- 取件码验证
- 包裹信息查询
- 取件确认
- 状态更新（待取→已取）

### 3.4 包裹寄件模块
- 寄件信息登记
- 运费自动计算
- 快递公司选择
- 寄件状态跟踪

### 3.5 滞留件处理模块
- 滞留件自动识别（基于时间规则）
- 滞留提醒（短信/邮件通知）
- 滞留件退回流程
- 滞留费用计算

### 3.6 货架管理模块
- 货架信息管理（位置、容量）
- 货架占用率查询
- 货架状态监控
- 智能货架分配

### 3.7 查询统计模块
- 包裹多维度查询（取件码、手机号、身份证号）
- 业务统计报表
- 性能监控
- 数据可视化

### 3.8 系统管理模块
- 系统配置管理
- 操作日志记录
- 数据备份恢复
- 权限管理

## 4. 数据流转设计

### 4.1 包裹状态流转

```
入库 (RECEIVED)
   ↓
上架 (SHELVED)
   ↓
待取 (READY_FOR_PICKUP)
   ↓
已取 (PICKED_UP)

异常流程：
   → 滞留 (OVERDUE)
   → 退回 (RETURNED)
```

### 4.2 业务流程关键点

#### 包裹入库流程
1. 扫描/录入包裹单号
2. OCR识别收件人信息
3. 生成唯一取件码
4. 执行货架分配算法
5. 更新包裹状态为"待上架"
6. 发送取件通知（短信/微信）

#### 包裹取件流程
1. 用户输入取件码
2. 验证取件码有效性
3. 查询包裹信息和货架位置
4. 员工根据货架号取出包裹
5. 确认取件并更新状态
6. 释放货架空间

#### 滞留件处理流程
1. 定时任务扫描超期包裹
2. 标记为滞留状态
3. 发送滞留提醒
4. 超过最大滞留期限自动退回
5. 计算滞留费用

## 5. 性能优化策略

### 5.1 数据库层面
- 合理设计索引（B-Tree索引、复合索引）
- 分区表设计（按时间分区历史数据）
- 读写分离（主从复制）
- 连接池优化
- 查询语句优化（避免全表扫描）

### 5.2 应用层面
- 缓存热点数据（Redis）
- 分页查询优化
- 批量操作优化
- 异步处理（消息队列）
- API响应压缩

### 5.3 前端层面
- 虚拟滚动（大数据列表）
- 懒加载
- 防抖和节流
- 前端缓存

## 6. 安全性设计

### 6.1 认证与授权
- JWT Token身份认证
- 基于角色的访问控制（RBAC）
- Token过期和刷新机制
- 敏感操作二次验证

### 6.2 数据安全
- 密码加密存储（bcrypt）
- SQL注入防护（参数化查询）
- XSS攻击防护
- CSRF防护
- 敏感数据脱敏

### 6.3 操作审计
- 关键操作日志记录
- 数据变更追踪
- 异常访问监控

## 7. 可扩展性设计

### 7.1 水平扩展能力
- 无状态服务设计
- 数据库分片支持
- 负载均衡

### 7.2 功能扩展能力
- 插件化架构
- 开放API接口
- 微服务改造预留

### 7.3 第三方集成
- OCR服务接口
- 短信通知接口
- 快递公司API接口
- 支付接口（预留）

## 8. 部署架构

### 8.1 开发环境
- 本地开发：SQLite + 内存缓存
- 热重载：nunu run
- 容器化开发环境：Docker Compose

### 8.2 生产环境
- 应用服务器：多实例部署
- 数据库：PostgreSQL主从架构
- 反向代理：Nginx
- 容器编排：Docker Swarm / Kubernetes（可选）

## 9. 监控与运维

### 9.1 日志管理
- 分级日志（Debug, Info, Warn, Error）
- 日志集中收集
- 日志分析和告警

### 9.2 性能监控
- 数据库性能监控
- API响应时间监控
- 系统资源监控

### 9.3 健康检查
- 服务健康检查接口
- 数据库连接状态检查
- 定时任务执行状态检查

## 10. 开发规范

### 10.1 代码规范
- 遵循Go官方代码规范
- 使用golangci-lint进行代码检查
- 代码注释要求（Swagger注解）

### 10.2 Git工作流
- 功能分支开发
- Code Review要求
- 提交信息规范

### 10.3 测试规范
- 单元测试覆盖率要求（>80%）
- 集成测试
- 性能测试

## 11. 项目里程碑

### Phase 1: 基础架构搭建（已完成）
- 项目初始化
- 基础框架搭建
- 用户认证模块

### Phase 2: 核心功能开发
- 数据库设计与实现
- 包裹管理核心功能
- 货架管理功能

### Phase 3: 高级功能开发
- OCR集成
- 智能货架分配算法
- 滞留件处理
- 运费计算

### Phase 4: 前端开发
- 页面开发
- 前后端联调

### Phase 5: 测试与优化
- 功能测试
- 性能测试与优化
- 安全测试

### Phase 6: 部署与文档
- 系统部署
- 用户手册编写
- 技术文档完善
